/*!
 * Tiny Import from Word plugin
 *
 * Copyright (c) 2024 Ephox Corporation DBA Tiny Technologies, Inc.
 * Licensed under the Tiny commercial license. See https://www.tiny.cloud/legal/
 *
 * Version: 7.5.1-62
 */

!(function () {
  'use strict';
  const r = r => parseInt(r, 10),
    t = (r, t) => {
      const e = r - t;
      return 0 === e ? 0 : e > 0 ? 1 : -1;
    },
    e = (r, t, e) => ({ major: r, minor: t, patch: e }),
    o = t => {
      const o = /([0-9]+)\.([0-9]+)\.([0-9]+)(?:(\-.+)?)/.exec(t);
      return o ? e(r(o[1]), r(o[2]), r(o[3])) : e(0, 0, 0);
    },
    n = Object.getPrototypeOf,
    i = (r, t, e) => {
      var o;
      return !!e(r, t.prototype) || (null === (o = r.constructor) || void 0 === o ? void 0 : o.name) === t.name;
    },
    s = r => t =>
      (r => {
        const t = typeof r;
        return null === r
          ? 'null'
          : 'object' === t && Array.isArray(r)
          ? 'array'
          : 'object' === t && i(r, String, (r, t) => t.isPrototypeOf(r))
          ? 'string'
          : t;
      })(t) === r,
    a = r => t => typeof t === r,
    c = s('string'),
    u = s('object'),
    l = r => ((r, t) => u(r) && i(r, t, (r, t) => n(r) === t))(r, Object),
    p = a('boolean'),
    d = a('function'),
    h = () => {},
    m = r => () => r,
    g = r => r,
    f = r => r(),
    v = m(!1),
    y = m(!0);
  class w {
    constructor(r, t) {
      (this.tag = r), (this.value = t);
    }
    static some(r) {
      return new w(!0, r);
    }
    static none() {
      return w.singletonNone;
    }
    fold(r, t) {
      return this.tag ? t(this.value) : r();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(r) {
      return this.tag ? w.some(r(this.value)) : w.none();
    }
    bind(r) {
      return this.tag ? r(this.value) : w.none();
    }
    exists(r) {
      return this.tag && r(this.value);
    }
    forall(r) {
      return !this.tag || r(this.value);
    }
    filter(r) {
      return !this.tag || r(this.value) ? this : w.none();
    }
    getOr(r) {
      return this.tag ? this.value : r;
    }
    or(r) {
      return this.tag ? this : r;
    }
    getOrThunk(r) {
      return this.tag ? this.value : r();
    }
    orThunk(r) {
      return this.tag ? this : r();
    }
    getOrDie(r) {
      if (this.tag) return this.value;
      throw new Error(null != r ? r : 'Called getOrDie on None');
    }
    static from(r) {
      return null == r ? w.none() : w.some(r);
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(r) {
      this.tag && r(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : 'none()';
    }
  }
  w.singletonNone = new w(!1);
  const _ = Array.prototype.indexOf,
    O = (r, t) => {
      const e = r.length,
        o = new Array(e);
      for (let n = 0; n < e; n++) {
        const e = r[n];
        o[n] = t(e, n);
      }
      return o;
    },
    k = r => {
      const t = t => t(r),
        e = m(r),
        o = () => n,
        n = {
          tag: !0,
          inner: r,
          fold: (t, e) => e(r),
          isValue: y,
          isError: v,
          map: t => j.value(t(r)),
          mapError: o,
          bind: t,
          exists: t,
          forall: t,
          getOr: e,
          or: o,
          getOrThunk: e,
          orThunk: o,
          getOrDie: e,
          each: t => {
            t(r);
          },
          toOptional: () => w.some(r)
        };
      return n;
    },
    E = r => {
      const t = () => e,
        e = {
          tag: !1,
          inner: r,
          fold: (t, e) => t(r),
          isValue: v,
          isError: y,
          map: t,
          mapError: t => j.error(t(r)),
          bind: t,
          exists: v,
          forall: y,
          getOr: g,
          or: g,
          getOrThunk: f,
          orThunk: f,
          getOrDie:
            ((o = String(r)),
            () => {
              throw new Error(o);
            }),
          each: h,
          toOptional: w.none
        };
      var o;
      return e;
    },
    j = { value: k, error: E, fromOption: (r, t) => r.fold(() => E(t), k) };
  var b;
  !(function (r) {
    (r[(r.Error = 0)] = 'Error'), (r[(r.Value = 1)] = 'Value');
  })(b || (b = {}));
  const T = (r, t, e) => (r.stype === b.Error ? t(r.serror) : e(r.svalue)),
    x = r => ({ stype: b.Value, svalue: r }),
    I = r => ({ stype: b.Error, serror: r }),
    S = T,
    P = (r, t, e) => {
      switch (r.tag) {
        case 'field':
          return t(r.key, r.newKey, r.presence, r.prop);
        case 'custom':
          return e(r.newKey, r.instantiator);
      }
    },
    N = Object.keys,
    V = Object.hasOwnProperty,
    W = (r, t) => (A(r, t) ? w.from(r[t]) : w.none()),
    A = (r, t) => V.call(r, t),
    C =
      ((D = (r, t) => (l(r) && l(t) ? C(r, t) : t)),
      (...r) => {
        if (0 === r.length) throw new Error("Can't merge zero objects");
        const t = {};
        for (let e = 0; e < r.length; e++) {
          const o = r[e];
          for (const r in o) A(o, r) && (t[r] = D(t[r], o[r]));
        }
        return t;
      });
  var D;
  const L = r => (u(r) && N(r).length > 100 ? ' removed due to size' : JSON.stringify(r, null, 2)),
    R = (r, t) => I([{ path: r, getErrorInfo: t }]),
    U = r => ({
      extract: (t, e) => {
        return (o = r(e)), (n = r => ((r, t) => R(r, m(t)))(t, r)), o.stype === b.Error ? n(o.serror) : o;
        var o, n;
      },
      toString: m('val')
    }),
    q = (r, t, e, o) => o(W(r, t).getOrThunk(() => e(r))),
    z = (r, t, e, o, n) => {
      const i = r => n.extract(t.concat([o]), r),
        s = r =>
          r.fold(
            () => x(w.none()),
            r => {
              const e = n.extract(t.concat([o]), r);
              return (i = e), (s = w.some), i.stype === b.Value ? { stype: b.Value, svalue: s(i.svalue) } : i;
              var i, s;
            }
          );
      switch (r.tag) {
        case 'required':
          return ((r, t, e, o) =>
            W(t, e).fold(
              () =>
                ((r, t, e) => R(r, () => 'Could not find valid *required* value for "' + t + '" in ' + L(e)))(r, e, t),
              o
            ))(t, e, o, i);
        case 'defaultedThunk':
          return q(e, o, r.process, i);
        case 'option':
          return ((r, t, e) => e(W(r, t)))(e, o, s);
        case 'defaultedOptionThunk':
          return ((r, t, e, o) => o(W(r, t).map(t => (!0 === t ? e(r) : t))))(e, o, r.process, s);
        case 'mergeWithThunk':
          return q(e, o, m({}), t => {
            const o = C(r.process(e), t);
            return i(o);
          });
      }
    },
    M = r => ({
      extract: (t, e) =>
        ((r, t, e) => {
          const o = {},
            n = [];
          for (const i of e)
            P(
              i,
              (e, i, s, a) => {
                const c = z(s, r, t, e, a);
                S(
                  c,
                  r => {
                    n.push(...r);
                  },
                  r => {
                    o[i] = r;
                  }
                );
              },
              (r, e) => {
                o[r] = e(t);
              }
            );
          return n.length > 0 ? I(n) : x(o);
        })(t, e, r),
      toString: () => {
        const t = O(r, r =>
          P(
            r,
            (r, t, e, o) => r + ' -> ' + o.toString(),
            (r, t) => 'state(' + r + ')'
          )
        );
        return 'obj{\n' + t.join('\n') + '}';
      }
    }),
    F =
      ((K = p),
      'boolean',
      U(r => {
        const t = typeof r;
        return K(r) ? x(r) : I(`Expected type: boolean but got: ${t}`);
      }));
  var K;
  const $ = (r, t, e) => {
      return (
        (o = ((r, t, e) =>
          ((r, t) => (r.stype === b.Error ? { stype: b.Error, serror: t(r.serror) } : r))(t.extract([r], e), r => ({
            input: e,
            errors: r
          })))(r, t, e)),
        T(o, j.error, j.value)
      );
      var o;
    },
    B = r =>
      U(t =>
        (t => {
          return (
            (e = r),
            (o = t),
            _.call(e, o) > -1 ? j.value(t) : j.error(`Unsupported value: "${t}", choose one of "${r.join(', ')}".`)
          );
          var e, o;
        })(t).fold(I, x)
      ),
    H = (r, t) =>
      ((r, t, e, o) => ({ tag: 'field', key: r, newKey: t, presence: e, prop: o }))(
        r,
        r,
        { tag: 'option', process: {} },
        t
      ),
    J = (r, t) => H(r, B(t)),
    G = M([J('resets', ['none', 'inline']), J('defaults', ['none', 'inline']), J('styles', ['none', 'inline'])]),
    Q = M([H('formatting', G), ('default_styles', H('default_styles', F))]);
  const X = { formatting: { styles: 'inline', resets: 'inline', defaults: 'inline' } },
    Y = r => {
      const t = (r =>
          w
            .from('https://importdocx.api.tiny.cloud/v2/convert/docx-html')
            .map(r =>
              ((r, t) => {
                const e = new URL(r);
                return (e.pathname = '/v2/convert/docx-html'), (e.search = ''), (e.hash = ''), e.toString();
              })(r)
            )
            .getOrDie('The Import from Word plugin requires the importword_service_url to be configured'))(r),
        e = (r => w.from(r.options.get('importword_converter_options')).getOr(X))(r),
        o = document.createElement('input');
      (o.type = 'file'),
        (o.accept =
          'application/vnd.openxmlformats-officedocument.wordprocessingml.document, application/msword, .doc,.docx,.xml,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document'),
        o.addEventListener('change', async () => {
          var n;
          const i = null === (n = o.files) || void 0 === n ? void 0 : n.item(0);
          if (i) {
            r.setProgressState(!0);
            try {
              const o = await (async r =>
                  (r => w.from(r.options.get('importword_token_provider')))(r).fold(
                    () => Promise.resolve(w.none()),
                    async r => {
                      const t = r();
                      if (!(u((e = t)) && d(e.then) && d(e.catch)))
                        throw new Error('The token provider needs to return a promise');
                      var e;
                      const o = await t;
                      if (!u(o) || !c(o.token))
                        throw new Error(
                          'Token provider should return a promise with an object that has a token string property'
                        );
                      return w.some(o.token);
                    }
                  ))(r),
                { html: n } = await (async (r, t, e, o) => {
                  const n = new FormData();
                  n.append('config', JSON.stringify(e)), n.append('file', r, r.name);
                  const i = { method: 'POST', body: n };
                  return (
                    o.each(r => {
                      i.headers = { Authorization: r };
                    }),
                    window.fetch(t, i).then(r => r.json())
                  );
                })(i, t, e, o).then(r => (r.html ? r : Promise.reject(r)));
              r.insertContent(n),
                (r => {
                  r.dispatch('ImportFromWord');
                })(r);
            } catch (t) {
              console.error(t), r.notificationManager.open({ text: 'Operation failed' });
            } finally {
              r.setProgressState(!1);
            }
            o.remove();
          }
        }),
        o.click();
    },
    Z = (r, t) => r.execCommand(t);
  tinymce.PluginManager.requireLangPack(
    'importword',
    'ar,bg_BG,ca,cs,da,de,el,es,eu,fa,fi,fr_FR,he_IL,hi,hr,hu_HU,id,it,ja,kk,ko_KR,ms,nb_NO,nl,pl,pt_BR,pt_PT,ro,ru,sk,sl_SI,sv_SE,th_TH,tr,uk,vi,zh_CN,zh_TW'
  ),
    tinymce.PluginManager.add('importword', r => {
      ((r, e) =>
        !!r &&
        -1 ===
          ((r, e) => {
            const o = t(r.major, e.major);
            if (0 !== o) return o;
            const n = t(r.minor, e.minor);
            if (0 !== n) return n;
            const i = t(r.patch, e.patch);
            return 0 !== i ? i : 0;
          })((r => o((r => [r.majorVersion, r.minorVersion].join('.').split('.').slice(0, 3).join('.'))(r)))(r), o(e)))(
        tinymce,
        '7.0'
      )
        ? console.error('The importword plugin requires at least version 7.0 of TinyMCE.')
        : ((r => {
            r.options.register('importword_service_url', {
              processor: r => {
                try {
                  return new URL(r), { valid: !0, value: r };
                } catch (r) {
                  return { valid: !1, message: 'The value provided in importword_service_url is not a valid URL' };
                }
              }
            }),
              r.options.register('importword_token_provider', { processor: 'function' }),
              r.options.register('importword_converter_options', {
                processor: r =>
                  $('importword_converter_options', Q, r).fold(
                    r => {
                      return (
                        console.error(
                          'Errors: \n' +
                            (r => {
                              const t =
                                r.length > 10
                                  ? r
                                      .slice(0, 10)
                                      .concat([{ path: [], getErrorInfo: m('... (only showing first ten failures)') }])
                                  : r;
                              return O(t, r => 'Failed path: (' + r.path.join(' > ') + ')\n' + r.getErrorInfo());
                            })((t = r).errors).join('\n') +
                            '\n\nInput object: ' +
                            L(t.input)
                        ),
                        !1
                      );
                      var t;
                    },
                    r => !0
                  )
              });
          })(r),
          (r => {
            r.addCommand('ImportWord', () => {
              (r => {
                Y(r);
              })(r);
            });
          })(r),
          (r => {
            r.ui.registry.addButton('importword', {
              tooltip: 'Import from Word',
              icon: 'import-word',
              onAction: () => {
                Z(r, 'ImportWord');
              }
            });
          })(r),
          (r => {
            r.ui.registry.addMenuItem('importword', {
              text: 'Import from Word...',
              icon: 'import-word',
              onAction: () => Z(r, 'ImportWord')
            });
          })(r));
    });
})();
