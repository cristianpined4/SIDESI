/*!
 * Tiny Spelling Autocorrect plugin
 *
 * Copyright (c) 2023 Ephox Corporation DBA Tiny Technologies, Inc.
 * Licensed under the Tiny commercial license. See https://www.tiny.cloud/legal/
 *
 * Version: 7.5.1-113
 */

!(function () {
  'use strict';
  const t = t => parseInt(t, 10),
    e = (t, e) => {
      const r = t - e;
      return 0 === r ? 0 : r > 0 ? 1 : -1;
    },
    r = (t, e, r) => ({ major: t, minor: e, patch: r }),
    o = e => {
      const o = /([0-9]+)\.([0-9]+)\.([0-9]+)(?:(\-.+)?)/.exec(e);
      return o ? r(t(o[1]), t(o[2]), t(o[3])) : r(0, 0, 0);
    },
    n = t => e => e.options.get(t),
    s = n('autocorrect_capitalize'),
    a = n('autocorrect_autocorrect'),
    c =
      ('array',
      t =>
        'array' ===
        (t => {
          const e = typeof t;
          return null === t
            ? 'null'
            : 'object' === e && Array.isArray(t)
            ? 'array'
            : 'object' === e &&
              ((r = o = t),
              (n = String).prototype.isPrototypeOf(r) ||
                (null === (s = o.constructor) || void 0 === s ? void 0 : s.name) === n.name)
            ? 'string'
            : e;
          var r, o, n, s;
        })(t));
  const i = (void 0, t => undefined === t);
  const u = t => 'function' == typeof t;
  class l {
    constructor(t, e) {
      (this.tag = t), (this.value = e);
    }
    static some(t) {
      return new l(!0, t);
    }
    static none() {
      return l.singletonNone;
    }
    fold(t, e) {
      return this.tag ? e(this.value) : t();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(t) {
      return this.tag ? l.some(t(this.value)) : l.none();
    }
    bind(t) {
      return this.tag ? t(this.value) : l.none();
    }
    exists(t) {
      return this.tag && t(this.value);
    }
    forall(t) {
      return !this.tag || t(this.value);
    }
    filter(t) {
      return !this.tag || t(this.value) ? this : l.none();
    }
    getOr(t) {
      return this.tag ? this.value : t;
    }
    or(t) {
      return this.tag ? this : t;
    }
    getOrThunk(t) {
      return this.tag ? this.value : t();
    }
    orThunk(t) {
      return this.tag ? this : t();
    }
    getOrDie(t) {
      if (this.tag) return this.value;
      throw new Error(null != t ? t : 'Called getOrDie on None');
    }
    static from(t) {
      return null == t ? l.none() : l.some(t);
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(t) {
      this.tag && t(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : 'none()';
    }
  }
  l.singletonNone = new l(!1);
  const p = (t, e, r) => '' === e || (t.length >= e.length && t.substr(r, r + e.length) === e),
    g = t => ('' === t ? '' : t.charAt(0).toUpperCase() + t.substring(1)),
    h = (t, e) => p(t, e, 0),
    d = (t, e) => p(t, e, t.length - e.length),
    m = 'AutocorrectStart',
    f = 'AutocorrectEnd',
    y = m + ' ' + f,
    v = 'CapitalizeStart',
    T = 'CapitalizeEnd',
    _ = v + ' ' + T,
    w = t => {
      t.dispatch(m);
    },
    x = t => {
      t.dispatch(f);
    },
    O = t => t.dispatch(v),
    b = t => t.dispatch(T),
    S = (t, e, r) => {
      (r.cache ? e.autocorrect().setAndCache : e.autocorrect().set)(r.on), (r.on ? w : x)(t);
    },
    k = (t, e, r) => {
      (r.cache ? e.capitalize().setAndCache : e.capitalize().set)(r.on), (r.on ? O : b)(t);
    },
    z = t => {
      let e = t;
      return {
        get: () => e,
        set: t => {
          e = t;
        }
      };
    },
    A = () => {},
    N = t => () => t,
    j = t => t,
    C = t => t(),
    R = N(!1),
    E = N(!0),
    I = Object.keys,
    F = (t, e) => {
      const r = I(t);
      for (let o = 0, n = r.length; o < n; o++) {
        const n = r[o];
        e(t[n], n);
      }
    },
    J = Array.prototype.push,
    P = {
      normalisation: [new RegExp(['([A-Z][A-Z]+)', '([a-z]+)', '(\\s*)', '$'].join(''))],
      capitalisation: [
        new RegExp(['([.?!]\\s+)', '([a-z][^\\s]+)', '(\\s*)', '$'].join('')),
        new RegExp(['^()', '([a-z][^\\s]*)', '(\\s*)', '$'].join(''))
      ],
      autocorrect: [new RegExp(['(^|\\W)', '(\\w+)', '(\\W*)', '(\\s*)', '$'].join(''))]
    },
    D = t => {
      const e = ['all', 'start', 'word', 'endOfWord', 'space'];
      return {
        regexes: P.autocorrect,
        identify: r => {
          if (r && r.length >= e.length) {
            const e = r[2],
              o = r[3] + r[4],
              n = e + o;
            return t.lookup(e).map(t => ({ start: n, replacement: t + o }));
          }
          return l.none();
        }
      };
    },
    $ = (t, e) =>
      (t => {
        const e = [];
        for (let r = 0, o = t.length; r < o; ++r) {
          if (!c(t[r])) throw new Error('Arr.flatten item ' + r + ' was not an array, input: ' + t);
          J.apply(e, t[r]);
        }
        return e;
      })(
        ((t, e) => {
          const r = t.length,
            o = new Array(r);
          for (let n = 0; n < r; n++) {
            const r = t[n];
            o[n] = e(r, n);
          }
          return o;
        })(e, e =>
          ((t, e) => {
            for (let r = 0; r < t.length; r++) {
              const o = e(t[r]);
              if (o.isSome()) return o;
            }
            return l.none();
          })(e.regexes, r => {
            const o = t.match(r);
            return null !== o ? e.identify(o) : l.none();
          }).toArray()
        )
      );
  var q;
  !(function (t) {
    (t.JSON = 'json'),
      (t.Blob = 'blob'),
      (t.Text = 'text'),
      (t.FormData = 'formdata'),
      (t.MultipartFormData = 'multipart/form-data');
  })(q || (q = {}));
  const M = t => {
      let e = l.none(),
        r = [];
      const o = t => {
          n() ? s(t) : r.push(t);
        },
        n = () => e.isSome(),
        s = t => {
          e.each(e => {
            setTimeout(() => {
              t(e);
            }, 0);
          });
        };
      return (
        t(t => {
          n() ||
            ((e = l.some(t)),
            ((t, e) => {
              for (let r = 0, o = t.length; r < o; r++) e(t[r], r);
            })(r, s),
            (r = []));
        }),
        {
          get: o,
          map: t =>
            M(e => {
              o(r => {
                e(t(r));
              });
            }),
          isReady: n
        }
      );
    },
    B = {
      nu: M,
      pure: t =>
        M(e => {
          e(t);
        })
    },
    H = t => {
      setTimeout(() => {
        throw t;
      }, 0);
    },
    L = t => {
      const e = e => {
        t().then(e, H);
      };
      return {
        map: e => L(() => t().then(e)),
        bind: e => L(() => t().then(t => e(t).toPromise())),
        anonBind: e => L(() => t().then(() => e.toPromise())),
        toLazy: () => B.nu(e),
        toCached: () => {
          let e = null;
          return L(() => (null === e && (e = t()), e));
        },
        toPromise: t,
        get: e
      };
    },
    U = t => L(() => new Promise(t)),
    V = t => L(() => Promise.resolve(t)),
    W = t => {
      const e = e => e(t),
        r = N(t),
        o = () => n,
        n = {
          tag: !0,
          inner: t,
          fold: (e, r) => r(t),
          isValue: E,
          isError: R,
          map: e => Z.value(e(t)),
          mapError: o,
          bind: e,
          exists: e,
          forall: e,
          getOr: r,
          or: o,
          getOrThunk: r,
          orThunk: o,
          getOrDie: r,
          each: e => {
            e(t);
          },
          toOptional: () => l.some(t)
        };
      return n;
    },
    K = t => {
      const e = () => r,
        r = {
          tag: !1,
          inner: t,
          fold: (e, r) => e(t),
          isValue: R,
          isError: E,
          map: e,
          mapError: e => Z.error(e(t)),
          bind: e,
          exists: R,
          forall: E,
          getOr: j,
          or: j,
          getOrThunk: C,
          orThunk: C,
          getOrDie:
            ((o = String(t)),
            () => {
              throw new Error(o);
            }),
          each: A,
          toOptional: l.none
        };
      var o;
      return r;
    },
    Z = { value: W, error: K, fromOption: (t, e) => t.fold(() => K(e), W) },
    G = t => ({
      ...t,
      toCached: () => G(t.toCached()),
      bindFuture: e =>
        G(
          t.bind(t =>
            t.fold(
              t => V(Z.error(t)),
              t => e(t)
            )
          )
        ),
      bindResult: e => G(t.map(t => t.bind(e))),
      mapResult: e => G(t.map(t => t.map(e))),
      mapError: e => G(t.map(t => t.mapError(e))),
      foldResult: (e, r) => t.map(t => t.fold(e, r)),
      withTimeout: (e, r) =>
        G(
          U(o => {
            let n = !1;
            const s = setTimeout(() => {
              (n = !0), o(Z.error(r()));
            }, e);
            t.get(t => {
              n || (clearTimeout(s), o(t));
            });
          })
        )
    }),
    X = t => G(U(t)),
    Q = t => G(V(Z.value(t))),
    Y = 'undefined' != typeof window ? window : Function('return this;')(),
    tt = t =>
      U(e => {
        const r = new FileReader();
        (r.onload = t => {
          const r = t.target ? t.target.result : '';
          e(r);
        }),
          r.readAsText(t);
      }),
    et = t => {
      try {
        const e = JSON.parse(t);
        return Z.value(e);
      } catch (t) {
        return Z.error('Response was not JSON.');
      }
    },
    rt = t => V(t.response),
    ot = (t, e) =>
      0 === e.status
        ? 'Unknown HTTP error (possible cross-domain request)'
        : `Could not load url ${t}: ${(t =>
            '' === t.statusText ? (404 === t.status ? 'Not Found' : `Response code ${t.status}`) : t.statusText)(e)}`,
    nt = (t, e) =>
      e
        .map(e => {
          const r = ((t, e) => {
              const r = [];
              return (
                F(t, (t, e) => {
                  var o;
                  r.push(((o = t), encodeURIComponent(e) + '=' + encodeURIComponent(o)));
                }),
                r
              );
            })(e),
            o = ((t, e, r = 0, o) => {
              const n = t.indexOf(e, r);
              return -1 !== n && (!!i(o) || n + e.length <= o);
            })(t, '?')
              ? '&'
              : '?';
          return r.length > 0 ? t + o + r.join('&') : t;
        })
        .getOr(t),
    st = t =>
      X(e => {
        const r = new XMLHttpRequest();
        r.open(t.method, nt(t.url, l.from(t.query)), !0);
        const o = (t => {
          const e =
            ((r = t.body),
            l.from(r).bind(t => {
              switch (t.type) {
                case q.JSON:
                  return l.some('application/json');
                case q.FormData:
                  return l.some('application/x-www-form-urlencoded; charset=UTF-8');
                case q.MultipartFormData:
                  return l.none();
                case q.Text:
                default:
                  return l.some('text/plain');
              }
            }));
          var r;
          const o = !0 === t.credentials ? l.some(!0) : l.none(),
            n =
              (t => {
                switch (t) {
                  case q.Blob:
                    return 'application/octet-stream';
                  case q.JSON:
                    return 'application/json, text/javascript';
                  case q.Text:
                    return 'text/plain';
                  default:
                    return '';
                }
              })(t.responseType) + ', */*; q=0.01',
            s = void 0 !== t.headers ? t.headers : {};
          return {
            contentType: e,
            responseType: (t => {
              switch (t) {
                case q.JSON:
                  return l.none();
                case q.Blob:
                  return l.some('blob');
                case q.Text:
                  return l.some('text');
                default:
                  return l.none();
              }
            })(t.responseType),
            credentials: o,
            accept: n,
            headers: s,
            progress: u(t.progress) ? l.some(t.progress) : l.none()
          };
        })(t);
        ((t, e) => {
          e.contentType.each(e => t.setRequestHeader('Content-Type', e)),
            t.setRequestHeader('Accept', e.accept),
            e.credentials.each(e => (t.withCredentials = e)),
            e.responseType.each(e => (t.responseType = e)),
            e.progress.each(e => t.upload.addEventListener('progress', t => e(t.loaded, t.total))),
            F(e.headers, (e, r) => t.setRequestHeader(r, e));
        })(r, o);
        const n = () => {
          ((t, e, r) =>
            ((t, e) => {
              switch (t) {
                case q.JSON:
                  return et(e.response).fold(() => rt(e), V);
                case q.Blob:
                  return (t => l.from(t.response).map(tt).getOr(V('no response content')))(e);
                case q.Text:
                default:
                  return rt(e);
              }
            })(e, r).map(e => ({ message: ot(t, r), status: r.status, responseText: e })))(
            t.url,
            t.responseType,
            r
          ).get(t => e(Z.error(t)));
        };
        var s;
        (r.onerror = n),
          (r.onload = () => {
            0 !== r.status || h(t.url, 'file:')
              ? r.status < 100 || r.status >= 400
                ? n()
                : ((t, e) => {
                    const r = t =>
                      (t => G(V(Z.error(t))))({ message: t, status: e.status, responseText: e.responseText });
                    switch (t) {
                      case q.JSON:
                        return et(e.response).fold(r, Q);
                      case q.Blob:
                      case q.Text:
                        return Q(e.response);
                      default:
                        return r('unknown data type');
                    }
                  })(t.responseType, r).get(e)
              : n();
          }),
          ((s = t.body),
          l.from(s).map(t =>
            t.type === q.JSON
              ? JSON.stringify(t.data)
              : t.type === q.FormData || t.type === q.MultipartFormData
              ? (t => {
                  const e = new FormData();
                  return (
                    F(t, (t, r) => {
                      e.append(r, t);
                    }),
                    e
                  );
                })(t.data)
              : t.data
          )).fold(
            () => r.send(),
            t => {
              r.send(t);
            }
          );
      }),
    at = '2',
    ct = (() => {
      try {
        const t = Y.localStorage,
          e = '__storage_test__';
        return t.setItem(e, e), t.removeItem(e), l.some(t);
      } catch (t) {
        return l.none();
      }
    })().fold(
      () => {
        const t = {};
        return {
          getItem: e => t[e],
          setItem: (e, r) => {
            t[e] = r;
          }
        };
      },
      t => ({
        getItem: e => t.getItem('mce.' + e),
        setItem: (e, r) => {
          t.setItem('mce.' + e, r);
        }
      })
    ),
    it = (t, e) => {
      const r = ((t, e) => {
          const r = (t => l.from(ct.getItem(t)))(t).map(JSON.parse);
          return r.getOr(e);
        })(t, e),
        o = z(r),
        n = t => {
          o.set(t);
        };
      return {
        get: () => o.get(),
        set: n,
        setAndCache: e => {
          n(e),
            ((t, e) => {
              const r = JSON.stringify(e);
              ct.setItem(t, r);
            })(t, e);
        }
      };
    };
  (() => {
    tinymce.PluginManager.requireLangPack(
      'autocorrect',
      'ar,bg_BG,ca,cs,da,de,el,es,eu,fa,fi,fr_FR,he_IL,hi,hr,hu_HU,id,it,ja,kk,ko_KR,ms,nb_NO,nl,pl,pt_BR,pt_PT,ro,ru,sk,sl_SI,sv_SE,th_TH,tr,uk,vi,zh_CN,zh_TW'
    );
    const t = t =>
      (t => {
        const e = z({});
        return (
          t.autocorrect().get(t => {
            t.fold(
              t => {
                console.error('Error loading autocorrect list');
              },
              t => {
                const r = ((t, e) => {
                  const r = {};
                  var o;
                  return (
                    ((t, e, r, o) => {
                      F(t, (t, n) => {
                        (e(t, n) ? r : o)(t, n);
                      });
                    })(
                      t,
                      e,
                      ((o = r),
                      (t, e) => {
                        o[e] = t;
                      }),
                      A
                    ),
                    r
                  );
                })(t.corrections, (t, e) => !(1 === t.length && e.length > 1));
                e.set(r);
              }
            );
          }),
          { lookup: t => l.from(e.get()[t]) }
        );
      })(
        (t => {
          const e = (t =>
              t.options.isSet('autocorrect_service_url')
                ? t.options.get('autocorrect_service_url')
                : t.options.get('autocorrect_rpc_url'))(t),
            r = (t =>
              t.options.isSet('autocorrect_api_key') ? t.options.get('autocorrect_api_key') : t.options.get('api_key'))(
              t
            );
          var o;
          const n =
            ((s = {
              url: `${[((o = e), d(o, '/') ? ((t, e) => t.substring(0, t.length - 1))(o) : o), at].join(
                '/'
              )}/autocorrect.json`,
              responseType: q.JSON,
              credentials: !0
            }),
            st({ ...s, method: 'get', body: { type: q.Text, data: '' } }));
          var s;
          return { autocorrect: N(n) };
        })(t)
      );
    tinymce.PluginManager.add('autocorrect', r => {
      if (
        ((t, r) =>
          !!t &&
          -1 ===
            ((t, r) => {
              const o = e(t.major, r.major);
              if (0 !== o) return o;
              const n = e(t.minor, r.minor);
              if (0 !== n) return n;
              const s = e(t.patch, r.patch);
              return 0 !== s ? s : 0;
            })(
              (t => o((t => [t.majorVersion, t.minorVersion].join('.').split('.').slice(0, 3).join('.'))(t)))(t),
              o(r)
            ))(tinymce, '6.6.0')
      )
        return void console.error('The autocorrect plugin requires at least version 6.6.0 of TinyMCE.');
      (t => {
        const e = t.options.register;
        e('autocorrect_api_key', { processor: 'string' }),
          e('autocorrect_rpc_url', { processor: 'string', default: '' }),
          e('autocorrect_service_url', { processor: 'string', default: '' }),
          e('autocorrect_capitalize', { processor: 'boolean', default: !1 }),
          e('autocorrect_autocorrect', { processor: 'boolean', default: !0 });
      })(r);
      const n = (t => {
        const e = it('autocorrect', t.autocorrect),
          r = it('capitalize', t.capitalize);
        return { autocorrect: N(e), capitalize: N(r) };
      })({ autocorrect: a(r), capitalize: s(r) });
      ((t, e) => {
        t.on('SpellcheckerLanguageChanged', r => {
          return (
            (o = r.language),
            void (
              h(o, 'en') ||
              (e.autocorrect().get() && S(t, e, { on: !1, cache: !1 }),
              e.capitalize().get() && k(t, e, { on: !1, cache: !1 }))
            )
          );
          var o;
        });
      })(r, n),
        ((t, e) => {
          t.ui.registry.addToggleMenuItem('autocorrect', {
            text: 'Autocorrect',
            onAction: () => {
              ((t, e) => {
                const r = e.autocorrect().get();
                S(t, e, { on: !r, cache: !0 });
              })(t, e);
            },
            onSetup: r => {
              const o = () => r.setActive(e.autocorrect().get());
              return o(), t.on(y, o), () => t.off(y, o);
            }
          }),
            t.ui.registry.addToggleMenuItem('capitalization', {
              text: 'Capitalization',
              onAction: () => {
                ((t, e) => {
                  const r = e.capitalize().get();
                  k(t, e, { on: !r, cache: !0 });
                })(t, e);
              },
              onSetup: r => {
                const o = () => r.setActive(e.capitalize().get());
                return o(), t.on(_, o), () => t.off(_, o);
              }
            });
        })(r, n);
      const c = ((t, e) => ({
          lookupPatterns: r => {
            const o = [
              ...(e.autocorrect().get() ? [D(t)] : []),
              ...(e.capitalize().get()
                ? [
                    {
                      regexes: P.capitalisation,
                      identify: t => {
                        var e;
                        if (t.length >= 4) {
                          const r = t[2] + t[3],
                            o = g(t[2]) + (null !== (e = t[3]) && void 0 !== e ? e : '');
                          return l.some({ start: r, replacement: o });
                        }
                        return l.none();
                      }
                    },
                    {
                      regexes: P.normalisation,
                      identify: t => {
                        var e;
                        if (t.length >= 4) {
                          const r = t[1] + t[2] + (null !== (e = t[3]) && void 0 !== e ? e : ''),
                            o = g(r.toLowerCase());
                          return l.some({ start: r, replacement: o });
                        }
                        return l.none();
                      }
                    }
                  ]
                : [])
            ];
            return $(r, o);
          }
        }))(t(r), n),
        i = (t => t.options.get('text_patterns_lookup'))(r);
      r.options.set('text_patterns_lookup', t => {
        const e = c.lookupPatterns(t.text);
        return [...i(t), ...e];
      });
    });
  })();
})();
