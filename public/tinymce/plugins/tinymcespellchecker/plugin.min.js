/*!
 * Tiny Spell Checker plugin
 *
 * Copyright (c) 2023 Ephox Corporation DBA Tiny Technologies, Inc.
 * Licensed under the Tiny commercial license. See https://www.tiny.cloud/legal/
 *
 * Version: 7.5.1-113
 */

!(function () {
  'use strict';
  const e = Object.getPrototypeOf,
    t = (e, t, n) => {
      var r;
      return !!n(e, t.prototype) || (null === (r = e.constructor) || void 0 === r ? void 0 : r.name) === t.name;
    },
    n = e => n =>
      (e => {
        const n = typeof e;
        return null === e
          ? 'null'
          : 'object' === n && Array.isArray(e)
          ? 'array'
          : 'object' === n && t(e, String, (e, t) => t.isPrototypeOf(e))
          ? 'string'
          : n;
      })(n) === e,
    r = e => t => typeof t === e,
    o = e => t => e === t,
    s = n('string'),
    l = n('object'),
    a = n => ((n, r) => l(n) && t(n, r, (t, n) => e(t) === n))(n, Object),
    i = n('array'),
    c = o(null),
    u = r('boolean'),
    g = o(void 0),
    d = e => null == e,
    p = e => !d(e),
    m = r('function'),
    h = r('number'),
    f = (e, t) => {
      if (i(e)) {
        for (let n = 0, r = e.length; n < r; ++n) if (!t(e[n])) return !1;
        return !0;
      }
      return !1;
    },
    y = () => {},
    w =
      (e, t) =>
      (...n) =>
        e(t.apply(null, n)),
    b = e => () => e,
    v = e => e,
    x = (e, t) => e === t;
  function k(e, ...t) {
    return (...n) => {
      const r = t.concat(n);
      return e.apply(null, r);
    };
  }
  const T = e => e(),
    S = e => {
      e();
    },
    E = b(!1),
    O = b(!0);
  class C {
    constructor(e, t) {
      (this.tag = e), (this.value = t);
    }
    static some(e) {
      return new C(!0, e);
    }
    static none() {
      return C.singletonNone;
    }
    fold(e, t) {
      return this.tag ? t(this.value) : e();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(e) {
      return this.tag ? C.some(e(this.value)) : C.none();
    }
    bind(e) {
      return this.tag ? e(this.value) : C.none();
    }
    exists(e) {
      return this.tag && e(this.value);
    }
    forall(e) {
      return !this.tag || e(this.value);
    }
    filter(e) {
      return !this.tag || e(this.value) ? this : C.none();
    }
    getOr(e) {
      return this.tag ? this.value : e;
    }
    or(e) {
      return this.tag ? this : e;
    }
    getOrThunk(e) {
      return this.tag ? this.value : e();
    }
    orThunk(e) {
      return this.tag ? this : e();
    }
    getOrDie(e) {
      if (this.tag) return this.value;
      throw new Error(null != e ? e : 'Called getOrDie on None');
    }
    static from(e) {
      return p(e) ? C.some(e) : C.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(e) {
      this.tag && e(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : 'none()';
    }
  }
  C.singletonNone = new C(!1);
  const _ = Array.prototype.slice,
    A = Array.prototype.indexOf,
    N = Array.prototype.push,
    R = (e, t) => A.call(e, t),
    D = (e, t) => R(e, t) > -1,
    I = (e, t) => {
      for (let n = 0, r = e.length; n < r; n++) if (t(e[n], n)) return !0;
      return !1;
    },
    L = (e, t) => {
      const n = e.length,
        r = new Array(n);
      for (let o = 0; o < n; o++) {
        const n = e[o];
        r[o] = t(n, o);
      }
      return r;
    },
    j = (e, t) => {
      for (let n = 0, r = e.length; n < r; n++) t(e[n], n);
    },
    M = (e, t) => {
      const n = [];
      for (let r = 0, o = e.length; r < o; r++) {
        const o = e[r];
        t(o, r) && n.push(o);
      }
      return n;
    },
    P = (e, t, n) => (
      j(e, (e, r) => {
        n = t(n, e, r);
      }),
      n
    ),
    B = (e, t) =>
      ((e, t, n) => {
        for (let r = 0, o = e.length; r < o; r++) {
          const o = e[r];
          if (t(o, r)) return C.some(o);
          if (n(o, r)) break;
        }
        return C.none();
      })(e, t, E),
    z = (e, t) => {
      for (let n = 0, r = e.length; n < r; n++) if (t(e[n], n)) return C.some(n);
      return C.none();
    },
    W = (e, t) =>
      (e => {
        const t = [];
        for (let n = 0, r = e.length; n < r; ++n) {
          if (!i(e[n])) throw new Error('Arr.flatten item ' + n + ' was not an array, input: ' + e);
          N.apply(t, e[n]);
        }
        return t;
      })(L(e, t)),
    F = (e, t) => {
      for (let n = 0, r = e.length; n < r; ++n) if (!0 !== t(e[n], n)) return !1;
      return !0;
    },
    q = e => {
      const t = _.call(e, 0);
      return t.reverse(), t;
    },
    V = e => [e],
    U = (e, t) => (t >= 0 && t < e.length ? C.some(e[t]) : C.none()),
    $ = e => U(e, 0),
    H = (e, t) => {
      const n = [],
        r = m(t) ? e => I(n, n => t(n, e)) : e => D(n, e);
      for (let t = 0, o = e.length; t < o; t++) {
        const o = e[t];
        r(o) || n.push(o);
      }
      return n;
    },
    J = Object.keys,
    K = Object.hasOwnProperty,
    Z = (e, t) => {
      const n = J(e);
      for (let r = 0, o = n.length; r < o; r++) {
        const o = n[r];
        t(e[o], o);
      }
    },
    G = (e, t) => Y(e, (e, n) => ({ k: n, v: t(e, n) })),
    Y = (e, t) => {
      const n = {};
      return (
        Z(e, (e, r) => {
          const o = t(e, r);
          n[o.k] = o.v;
        }),
        n
      );
    },
    X = (e, t) => {
      const n = [];
      return (
        Z(e, (e, r) => {
          n.push(t(e, r));
        }),
        n
      );
    },
    Q = (e, t) => (ee(e, t) ? C.from(e[t]) : C.none()),
    ee = (e, t) => K.call(e, t),
    te = 'undefined' != typeof window ? window : Function('return this;')(),
    ne = (e, t) =>
      ((e, t) => {
        let n = null != t ? t : te;
        for (let t = 0; t < e.length && null != n; ++t) n = n[e[t]];
        return n;
      })(e.split('.'), t),
    re = Object.getPrototypeOf,
    oe = e => {
      const t = ne('ownerDocument.defaultView', e);
      return (
        l(e) &&
        ((e =>
          ((e, t) => {
            const n = ((e, t) => ne(e, t))(e, t);
            if (null == n) throw new Error(e + ' not available on this browser');
            return n;
          })('HTMLElement', e))(t).prototype.isPrototypeOf(e) ||
          /^HTML\w*Element$/.test(re(e).constructor.name))
      );
    },
    se = e => e.dom.nodeName.toLowerCase(),
    le = e => e.dom.nodeType,
    ae = e => t => le(t) === e,
    ie = e => 8 === le(e) || '#comment' === se(e),
    ce = e => ue(e) && oe(e.dom),
    ue = ae(1),
    ge = ae(3),
    de = ae(9),
    pe = ae(11),
    me = e => t => ue(t) && se(t) === e,
    he = (e, t, n) => {
      if (!(s(n) || u(n) || h(n)))
        throw (
          (console.error('Invalid call to Attribute.set. Key ', t, ':: Value ', n, ':: Element ', e),
          new Error('Attribute value was not simple'))
        );
      e.setAttribute(t, n + '');
    },
    fe = (e, t, n) => {
      he(e.dom, t, n);
    },
    ye = (e, t) => {
      const n = e.dom.getAttribute(t);
      return null === n ? void 0 : n;
    },
    we = (e, t) => C.from(ye(e, t)),
    be = (e, t) => {
      e.dom.removeAttribute(t);
    },
    ve = e => {
      if (null == e) throw new Error('Node cannot be null or undefined');
      return { dom: e };
    },
    xe = {
      fromHtml: (e, t) => {
        const n = (t || document).createElement('div');
        if (((n.innerHTML = e), !n.hasChildNodes() || n.childNodes.length > 1)) {
          const t = 'HTML does not have a single root node';
          throw (console.error(t, e), new Error(t));
        }
        return ve(n.childNodes[0]);
      },
      fromTag: (e, t) => {
        const n = (t || document).createElement(e);
        return ve(n);
      },
      fromText: (e, t) => {
        const n = (t || document).createTextNode(e);
        return ve(n);
      },
      fromDom: ve,
      fromPoint: (e, t, n) => C.from(e.dom.elementFromPoint(t, n)).map(ve)
    },
    ke = e => parseInt(e, 10),
    Te = (e, t) => {
      const n = e - t;
      return 0 === n ? 0 : n > 0 ? 1 : -1;
    },
    Se = (e, t, n) => ({ major: e, minor: t, patch: n }),
    Ee = e => {
      const t = /([0-9]+)\.([0-9]+)\.([0-9]+)(?:(\-.+)?)/.exec(e);
      return t ? Se(ke(t[1]), ke(t[2]), ke(t[3])) : Se(0, 0, 0);
    },
    Oe = (e, t) => {
      const n = e.dom;
      if (1 !== n.nodeType) return !1;
      {
        const e = n;
        if (void 0 !== e.matches) return e.matches(t);
        if (void 0 !== e.msMatchesSelector) return e.msMatchesSelector(t);
        if (void 0 !== e.webkitMatchesSelector) return e.webkitMatchesSelector(t);
        if (void 0 !== e.mozMatchesSelector) return e.mozMatchesSelector(t);
        throw new Error('Browser lacks native selectors');
      }
    },
    Ce = (e, t) => e.dom === t.dom,
    _e = Oe,
    Ae = (e, t, n = x) => e.exists(e => n(e, t)),
    Ne = (e, t, n) => '' === t || (e.length >= t.length && e.substr(n, n + t.length) === t),
    Re = (e, t, n = 0, r) => {
      const o = e.indexOf(t, n);
      return -1 !== o && (!!g(r) || o + t.length <= r);
    },
    De = ((Ie = /^\s+|\s+$/g), e => e.replace(Ie, ''));
  var Ie;
  const Le = e => void 0 !== e.style && m(e.style.getPropertyValue),
    je = e => xe.fromDom(e.dom.ownerDocument),
    Me = e => C.from(e.dom.parentNode).map(xe.fromDom),
    Pe = (e, t) => {
      const n = m(t) ? t : E;
      let r = e.dom;
      const o = [];
      for (; null !== r.parentNode && void 0 !== r.parentNode; ) {
        const e = r.parentNode,
          t = xe.fromDom(e);
        if ((o.push(t), !0 === n(t))) break;
        r = e;
      }
      return o;
    },
    Be = e => C.from(e.dom.previousSibling).map(xe.fromDom),
    ze = e => C.from(e.dom.nextSibling).map(xe.fromDom),
    We = e => L(e.dom.childNodes, xe.fromDom),
    Fe = (e, t) => {
      const n = e.dom.childNodes;
      return C.from(n[t]).map(xe.fromDom);
    },
    qe = e => e.dom.childNodes.length,
    Ve = (e, t) => ({ element: e, offset: t }),
    Ue = e => xe.fromDom(e.dom.host),
    $e = e => {
      const t = ge(e) ? e.dom.parentNode : e.dom;
      if (null == t || null === t.ownerDocument) return !1;
      const n = t.ownerDocument;
      return (e => {
        const t = (e => xe.fromDom(e.dom.getRootNode()))(e);
        return pe((n = t)) && p(n.dom.host) ? C.some(t) : C.none();
        var n;
      })(xe.fromDom(t)).fold(() => n.body.contains(t), ((r = $e), (o = Ue), e => r(o(e))));
      var r, o;
    },
    He = (e, t, n) => {
      ((e, t, n) => {
        if (!s(n))
          throw (
            (console.error('Invalid call to CSS.set. Property ', t, ':: Value ', n, ':: Element ', e),
            new Error('CSS value must be a string: ' + n))
          );
        Le(e) && e.style.setProperty(t, n);
      })(e.dom, t, n);
    },
    Je = (e, t) => {
      const n = e.dom,
        r = window.getComputedStyle(n).getPropertyValue(t);
      return '' !== r || $e(e) ? r : Ke(n, t);
    },
    Ke = (e, t) => (Le(e) ? e.style.getPropertyValue(t) : ''),
    Ze = (e, t) => {
      const n = e.dom,
        r = Ke(n, t);
      return C.from(r).filter(e => e.length > 0);
    },
    Ge = (e, t) => {
      ((e, t) => {
        Le(e) && e.style.removeProperty(t);
      })(e.dom, t),
        Ae(we(e, 'style').map(De), '') && be(e, 'style');
    },
    Ye = (e, t) => {
      Me(e).each(n => {
        n.dom.insertBefore(t.dom, e.dom);
      });
    },
    Xe = (e, t) => {
      ze(e).fold(
        () => {
          Me(e).each(e => {
            et(e, t);
          });
        },
        e => {
          Ye(e, t);
        }
      );
    },
    Qe = (e, t) => {
      const n = (e => Fe(e, 0))(e);
      n.fold(
        () => {
          et(e, t);
        },
        n => {
          e.dom.insertBefore(t.dom, n.dom);
        }
      );
    },
    et = (e, t) => {
      e.dom.appendChild(t.dom);
    },
    tt = (e, t) => {
      Ye(e, t), et(t, e);
    },
    nt = (e, t) => {
      j(t, (n, r) => {
        const o = 0 === r ? e : t[r - 1];
        Xe(o, n);
      });
    },
    rt = (e, t) => {
      j(t, t => {
        et(e, t);
      });
    },
    ot = (e, t) => {
      let n = [];
      return (
        j(We(e), e => {
          t(e) && (n = n.concat([e])), (n = n.concat(ot(e, t)));
        }),
        n
      );
    },
    st = (e, t, n) => {
      let r = e.dom;
      const o = m(n) ? n : E;
      for (; r.parentNode; ) {
        r = r.parentNode;
        const e = xe.fromDom(r);
        if (t(e)) return C.some(e);
        if (o(e)) break;
      }
      return C.none();
    },
    lt = e => {
      const t = e.dom;
      null !== t.parentNode && t.parentNode.removeChild(t);
    },
    at = e => {
      const t = We(e);
      t.length > 0 && nt(e, t), lt(e);
    },
    it = (e, t) =>
      ((e, t) => {
        const n = void 0 === t ? document : t.dom;
        return (1 !== (r = n).nodeType && 9 !== r.nodeType && 11 !== r.nodeType) || 0 === r.childElementCount
          ? []
          : L(n.querySelectorAll(e), xe.fromDom);
        var r;
      })(t, e),
    ct = (e, t, n) => st(e, e => Oe(e, t), n),
    ut = (e, t, n) =>
      ((e, t, n, r, o) => (((e, t) => Oe(e, t))(n, r) ? C.some(n) : m(o) && o(n) ? C.none() : t(n, r, o)))(
        0,
        ct,
        e,
        t,
        n
      ),
    gt = ((e, t) => {
      const n = t => (e(t) ? C.from(t.dom.nodeValue) : C.none());
      return {
        get: t => {
          if (!e(t)) throw new Error('Can only get text value of a text node');
          return n(t).getOr('');
        },
        getOption: n,
        set: (t, n) => {
          if (!e(t)) throw new Error('Can only set raw text value of a text node');
          t.dom.nodeValue = n;
        }
      };
    })(ge),
    dt = e => gt.get(e),
    pt = (e, t) => gt.set(e, t);
  var mt = [
      'body',
      'p',
      'div',
      'article',
      'aside',
      'figcaption',
      'figure',
      'footer',
      'header',
      'nav',
      'section',
      'ol',
      'ul',
      'li',
      'table',
      'thead',
      'tbody',
      'tfoot',
      'caption',
      'tr',
      'td',
      'th',
      'h1',
      'h2',
      'h3',
      'h4',
      'h5',
      'h6',
      'blockquote',
      'pre',
      'address'
    ],
    ht = () => ({
      up: b({ selector: ct, closest: ut, predicate: st, all: Pe }),
      down: b({ selector: it, predicate: ot }),
      styles: b({ get: Je, getRaw: Ze, set: He, remove: Ge }),
      attrs: b({
        get: ye,
        set: fe,
        remove: be,
        copyTo: (e, t) => {
          ((e, t) => {
            const n = e.dom;
            Z(t, (e, t) => {
              he(n, t, e);
            });
          })(
            t,
            P(e.dom.attributes, (e, t) => ((e[t.name] = t.value), e), {})
          );
        }
      }),
      insert: b({ before: Ye, after: Xe, afterAll: nt, append: et, appendAll: rt, prepend: Qe, wrap: tt }),
      remove: b({ unwrap: at, remove: lt }),
      create: b({ nu: xe.fromTag, clone: e => xe.fromDom(e.dom.cloneNode(!1)), text: xe.fromText }),
      query: b({ comparePosition: (e, t) => e.dom.compareDocumentPosition(t.dom), prevSibling: Be, nextSibling: ze }),
      property: b({
        children: We,
        name: se,
        parent: Me,
        document: e => {
          return ((t = e), de(t) ? t : je(t)).dom;
          var t;
        },
        isText: ge,
        isComment: ie,
        isElement: ue,
        isSpecial: e => {
          const t = se(e);
          return D(['script', 'noscript', 'iframe', 'noframes', 'noembed', 'title', 'style', 'textarea', 'xmp'], t);
        },
        getLanguage: e => (ue(e) ? we(e, 'lang') : C.none()),
        getText: dt,
        setText: pt,
        isBoundary: e => !!ue(e) && ('body' === se(e) || D(mt, se(e))),
        isEmptyTag: e => !!ue(e) && D(['br', 'img', 'hr', 'input'], se(e)),
        isNonEditable: e => ue(e) && 'false' === ye(e, 'contenteditable')
      }),
      eq: Ce,
      is: _e
    });
  const ft = (e, t) => ({ element: e, offset: t }),
    yt = (e, t, n) => ({ element: e, start: t, finish: n }),
    wt = e => {
      if (!i(e)) throw new Error('cases must be an array');
      if (0 === e.length) throw new Error('there must be at least one case');
      const t = [],
        n = {};
      return (
        j(e, (r, o) => {
          const s = J(r);
          if (1 !== s.length) throw new Error('one and only one name per case');
          const l = s[0],
            a = r[l];
          if (void 0 !== n[l]) throw new Error('duplicate key detected:' + l);
          if ('cata' === l) throw new Error('cannot have a case named cata (sorry)');
          if (!i(a)) throw new Error('case arguments must be an array');
          t.push(l),
            (n[l] = (...n) => {
              const r = n.length;
              if (r !== a.length)
                throw new Error(
                  'Wrong number of arguments to case ' + l + '. Expected ' + a.length + ' (' + a + '), got ' + r
                );
              return {
                fold: (...t) => {
                  if (t.length !== e.length)
                    throw new Error('Wrong number of arguments to fold. Expected ' + e.length + ', got ' + t.length);
                  return t[o].apply(null, n);
                },
                match: e => {
                  const r = J(e);
                  if (t.length !== r.length)
                    throw new Error(
                      'Wrong number of arguments to match. Expected: ' + t.join(',') + '\nActual: ' + r.join(',')
                    );
                  if (!F(t, e => D(r, e)))
                    throw new Error(
                      'Not all branches were specified when using match. Specified: ' +
                        r.join(', ') +
                        '\nRequired: ' +
                        t.join(', ')
                    );
                  return e[l].apply(null, n);
                },
                log: e => {
                  console.log(e, { constructors: t, constructor: l, params: n });
                }
              };
            });
        }),
        n
      );
    },
    bt = wt([
      { before: ['element'] },
      { after: ['element'] },
      { rest: ['element'] },
      { last: ['element'] },
      { invalid: ['element', 'offset'] }
    ]);
  bt.before, bt.after, bt.rest, bt.last, bt.invalid;
  const vt = (e, t) => z(e, e => e.start === t),
    xt = (e, t, n = 0) =>
      P(e, (e, n) => t(n, e.len).fold(b(e), t => ({ len: t.finish, list: e.list.concat([t]) })), { len: n, list: [] })
        .list,
    kt = (e, t, n) =>
      0 === t.length
        ? e
        : W(e, e => {
            const r = W(t, t => (((e, t) => t >= e.start && t <= e.finish)(e, t) ? [t - e.start] : []));
            return r.length > 0
              ? ((e, t, n) => {
                  return (r = n(e, t)), (o = e.start), L(r, e => ({ ...e, start: e.start + o, finish: e.finish + o }));
                  var r, o;
                })(e, r, n)
              : [e];
          }),
    Tt = wt([{ none: [] }, { start: ['element'] }, { middle: ['before', 'after'] }, { end: ['element'] }]);
  Tt.none, Tt.start, Tt.middle, Tt.end;
  const St = wt([{ include: ['item'] }, { excludeWith: ['item'] }, { excludeWithout: ['item'] }]),
    Et = {
      include: St.include,
      excludeWith: St.excludeWith,
      excludeWithout: St.excludeWithout,
      cata: (e, t, n, r) => e.fold(t, n, r)
    },
    Ot = wt([
      { boundary: ['item', 'universe'] },
      { empty: ['item', 'universe'] },
      { text: ['item', 'universe'] },
      { nonEditable: ['item', 'universe'] }
    ]),
    Ct = E,
    _t = O,
    At = b(0),
    Nt = b(1),
    Rt = e => ({
      ...e,
      isBoundary: () => e.fold(_t, Ct, Ct, Ct),
      toText: () => e.fold(C.none, C.none, e => C.some(e), C.none),
      is: t => e.fold(Ct, Ct, (e, n) => n.eq(e, t), Ct),
      len: () => e.fold(At, Nt, (e, t) => t.property().getText(e).length, Nt)
    }),
    Dt = {
      text: w(Rt, Ot.text),
      boundary: w(Rt, Ot.boundary),
      empty: w(Rt, Ot.empty),
      nonEditable: w(Rt, Ot.empty),
      cata: (e, t, n, r, o) => e.fold(t, n, r, o)
    },
    It = b([]),
    Lt = (e, t, n) => {
      if (e.property().isText(t)) return [Dt.text(t, e)];
      if (e.property().isEmptyTag(t)) return [Dt.empty(t, e)];
      if (e.property().isNonEditable(t)) return [];
      if (e.property().isElement(t)) {
        const r = e.property().children(t),
          o = e.property().isBoundary(t) ? [Dt.boundary(t, e)] : [],
          s = void 0 !== n && n(t) ? [] : W(r, t => Lt(e, t, n));
        return o.concat(s).concat(o);
      }
      return [];
    },
    jt = Lt,
    Mt = (e, t, n) => {
      const r = ((e, t) => {
        const n = [];
        let r = [];
        return (
          j(e, e => {
            const o = t(e);
            Et.cata(
              o,
              () => {
                r.push(e);
              },
              () => {
                r.length > 0 && n.push(r), n.push([e]), (r = []);
              },
              () => {
                r.length > 0 && n.push(r), (r = []);
              }
            );
          }),
          r.length > 0 && n.push(r),
          n
        );
      })(
        W(t, t => jt(e, t, n)),
        e =>
          e.match({
            boundary: () => Et.excludeWithout(e),
            empty: () => Et.excludeWith(e),
            text: () => Et.include(e),
            nonEditable: () => Et.excludeWithout(e)
          })
      );
      return M(r, e => e.length > 0);
    },
    Pt = (e, t) => {
      if (e.property().isText(t)) return ft(t, e.property().getText(t).length);
      {
        const n = e.property().children(t);
        return n.length > 0 ? Pt(e, n[n.length - 1]) : ft(t, n.length);
      }
    },
    Bt = (e, t, n) => {
      const r = e.property().children(t);
      return r.length > 0 && n < r.length
        ? Bt(e, r[n], 0)
        : r.length > 0 && e.property().isElement(t) && r.length === n
        ? Pt(e, r[r.length - 1])
        : ft(t, n);
    },
    zt = ht(),
    Wt = (e, t) => {
      const n = ye(e, t);
      return void 0 === n || '' === n ? [] : n.split(' ');
    },
    Ft = e => void 0 !== e.dom.classList,
    qt = (e, t) => {
      Ft(e)
        ? e.dom.classList.add(t)
        : ((e, t) => {
            ((e, t, n) => {
              const r = Wt(e, t).concat([n]);
              fe(e, t, r.join(' '));
            })(e, 'class', t);
          })(e, t);
    },
    Vt = (e, t) => {
      Ft(e)
        ? e.dom.classList.remove(t)
        : ((e, t) => {
            ((e, t, n) => {
              const r = M(Wt(e, t), e => e !== n);
              r.length > 0 ? fe(e, t, r.join(' ')) : be(e, t);
            })(e, 'class', t);
          })(e, t),
        (e => {
          const t = Ft(e) ? e.dom.classList : (e => Wt(e, 'class'))(e);
          0 === t.length && be(e, 'class');
        })(e);
    },
    Ut = e => e.dom.contentEditable,
    $t = Bt,
    Ht = (e, t) => k(e.eq, t),
    Jt = (e, t) => {
      const n = e.property();
      return n.getLanguage(t).orThunk(() =>
        ((e, t) => {
          for (let n = 0; n < e.length; n++) {
            const r = t(e[n], n);
            if (r.isSome()) return r;
          }
          return C.none();
        })(e.up().all(t, E), n.getLanguage)
      );
    },
    Kt = Jt,
    Zt = (e, t) => ({ item: e, mode: t }),
    Gt = (e, t, n, r = Yt) =>
      e
        .property()
        .parent(t)
        .map(e => Zt(e, r)),
    Yt = (e, t, n, r = Xt) => n.sibling(e, t).map(e => Zt(e, r)),
    Xt = (e, t, n, r = Xt) => {
      const o = e.property().children(t);
      return n.first(o).map(e => Zt(e, r));
    },
    Qt = [
      { current: Gt, next: Yt, fallback: C.none() },
      { current: Yt, next: Xt, fallback: C.some(Gt) },
      { current: Xt, next: Xt, fallback: C.some(Yt) }
    ],
    en = (e, t, n, r, o = Qt) =>
      B(o, e => e.current === n).bind(n =>
        n.current(e, t, r, n.next).orThunk(() => n.fallback.bind(n => en(e, t, n, r)))
      ),
    tn = {
      left: () => ({
        sibling: (e, t) => e.query().prevSibling(t),
        first: e => (e.length > 0 ? C.some(e[e.length - 1]) : C.none())
      }),
      right: () => ({
        sibling: (e, t) => e.query().nextSibling(t),
        first: e => (e.length > 0 ? C.some(e[0]) : C.none())
      })
    },
    nn = (e, t, n, r, o, s) =>
      en(e, t, r, o).bind(t => (s(t.item) ? C.none() : n(t.item) ? C.some(t.item) : nn(e, t.item, n, t.mode, o, s))),
    rn = (e, t, n, r) => nn(e, t, n, Yt, tn.right(), r),
    on = rn,
    sn = () => ({ left: tn.left, right: tn.right }),
    ln = en,
    an = (e, t, n, r) => ({ item: e, start: t, finish: n, text: r }),
    cn = (e, t) => ({ items: e, abort: t }),
    un = (e, t) => {
      const n = e.property().getText(t);
      return an(t, 0, n.length, n);
    },
    gn = (e, t, n) => cn([], !0),
    dn = (e, t, n) => cn([], !1),
    pn = (e, t, n) => {
      const r = e.property().getText(t);
      return n(r).fold(
        () => cn([an(t, 0, r.length, r)], !1),
        e => {
          const n = e[0] === e[1] ? [] : [an(t, e[0], e[1], r.substring(e[0], e[1]))];
          return cn(n, !0);
        }
      );
    },
    mn = un,
    hn = (e, t) => (e.property().isText(t) ? un(e, t) : an(t, 0, 0, '')),
    fn = (e, t, n, r) =>
      (e.property().isBoundary(t) || e.property().isEmptyTag(t) || r(e, t) ? gn : e.property().isText(t) ? pn : dn)(
        e,
        t,
        n
      ),
    yn = "[-'\\.\u2018\u2019\u2024\ufe52\uff07\uff0e]",
    wn = '[:\xb7\xb7\u05f4\u2027\ufe13\ufe55\uff1a]',
    bn = '[\xb1+*/,;;\u0589\u060c\u060d\u066c\u07f8\u2044\ufe10\ufe14\ufe50\ufe54\uff0c\uff1b]',
    vn =
      '[0-9\u0660-\u0669\u066b\u06f0-\u06f9\u07c0-\u07c9\u0966-\u096f\u09e6-\u09ef\u0a66-\u0a6f\u0ae6-\u0aef\u0b66-\u0b6f\u0be6-\u0bef\u0c66-\u0c6f\u0ce6-\u0cef\u0d66-\u0d6f\u0e50-\u0e59\u0ed0-\u0ed9\u0f20-\u0f29\u1040-\u1049\u1090-\u1099\u17e0-\u17e9\u1810-\u1819\u1946-\u194f\u19d0-\u19d9\u1a80-\u1a89\u1a90-\u1a99\u1b50-\u1b59\u1bb0-\u1bb9\u1c40-\u1c49\u1c50-\u1c59\ua620-\ua629\ua8d0-\ua8d9\ua900-\ua909\ua9d0-\ua9d9\uaa50-\uaa59\uabf0-\uabf9]',
    xn = '\\r',
    kn = '\\n',
    Tn = '[\v\f\x85\u2028\u2029]',
    Sn =
      '[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065f\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0c01-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d02\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f\u109a-\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b6-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u192b\u1930-\u193b\u19b0-\u19c0\u19c8\u19c9\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f\u1b00-\u1b04\u1b34-\u1b44\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1baa\u1be6-\u1bf3\u1c24-\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2\u1dc0-\u1de6\u1dfc-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa7b\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe3-\uabea\uabec\uabed\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]',
    En =
      '[\xad\u0600-\u0603\u06dd\u070f\u17b4\u17b5\u200e\u200f\u202a-\u202e\u2060-\u2064\u206a-\u206f\ufeff\ufff9-\ufffb]',
    On = '[\u3031-\u3035\u309b\u309c\u30a0-\u30fa\u30fc-\u30ff\u31f0-\u31ff\u32d0-\u32fe\u3300-\u3357\uff66-\uff9d]',
    Cn = '[=_\u203f\u2040\u2054\ufe33\ufe34\ufe4d-\ufe4f\uff3f\u2200-\u22ff<>]',
    _n =
      '[~\u2116|!-*+-\\/:;?@\\[-`{}\xa1\xab\xb7\xbb\xbf;\xb7\u055a-\u055f\u0589\u058a\u05be\u05c0\u05c3\u05c6\u05f3\u05f4\u0609\u060a\u060c\u060d\u061b\u061e\u061f\u066a-\u066d\u06d4\u0700-\u070d\u07f7-\u07f9\u0830-\u083e\u085e\u0964\u0965\u0970\u0df4\u0e4f\u0e5a\u0e5b\u0f04-\u0f12\u0f3a-\u0f3d\u0f85\u0fd0-\u0fd4\u0fd9\u0fda\u104a-\u104f\u10fb\u1361-\u1368\u1400\u166d\u166e\u169b\u169c\u16eb-\u16ed\u1735\u1736\u17d4-\u17d6\u17d8-\u17da\u1800-\u180a\u1944\u1945\u1a1e\u1a1f\u1aa0-\u1aa6\u1aa8-\u1aad\u1b5a-\u1b60\u1bfc-\u1bff\u1c3b-\u1c3f\u1c7e\u1c7f\u1cd3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205e\u207d\u207e\u208d\u208e\u3008\u3009\u2768-\u2775\u27c5\u27c6\u27e6-\u27ef\u2983-\u2998\u29d8-\u29db\u29fc\u29fd\u2cf9-\u2cfc\u2cfe\u2cff\u2d70\u2e00-\u2e2e\u2e30\u2e31\u3001-\u3003\u3008-\u3011\u3014-\u301f\u3030\u303d\u30a0\u30fb\ua4fe\ua4ff\ua60d-\ua60f\ua673\ua67e\ua6f2-\ua6f7\ua874-\ua877\ua8ce\ua8cf\ua8f8-\ua8fa\ua92e\ua92f\ua95f\ua9c1-\ua9cd\ua9de\ua9df\uaa5c-\uaa5f\uaade\uaadf\uabeb\ufd3e\ufd3f\ufe10-\ufe19\ufe30-\ufe52\ufe54-\ufe61\ufe63\ufe68\ufe6a\ufe6b\uff01-\uff03\uff05-\uff0a\uff0c-\uff0f\uff1a\uff1b\uff1f\uff20\uff3b-\uff3d\uff3f\uff5b\uff5d\uff5f-\uff65]',
    An = 10,
    Nn = [
      new RegExp(
        '[A-Za-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f3\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u10a0-\u10c5\u10d0-\u10fa\u10fc\u1100-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1a00-\u1a16\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bc0-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u24b6-\u24e9\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2d00-\u2d25\u2d30-\u2d65\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005\u303b\u303c\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790\ua791\ua7a0-\ua7a9\ua7fa-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uffa0-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]'
      ),
      new RegExp(yn),
      new RegExp(wn),
      new RegExp(bn),
      new RegExp(vn),
      new RegExp(xn),
      new RegExp(kn),
      new RegExp(Tn),
      new RegExp(Sn),
      new RegExp(En),
      new RegExp(On),
      new RegExp(Cn),
      new RegExp('@')
    ],
    Rn = new RegExp('^' + _n + '$'),
    Dn = b("[^\\w'\\-\xad\\u0100-\\u017F\\u00C0-\\u00FF\ufeff\\u2018\\u2019]"),
    In = (e, t, n, r) => ({ term: () => new RegExp(e, r.getOr('g')), prefix: t, suffix: n }),
    Ln = In,
    jn = Dn,
    Mn = (e, t) => {
      const n = t.term(),
        r = [];
      let o = n.exec(e);
      for (; o; ) {
        const s = o.index + t.prefix(o),
          l = o[0].length - t.prefix(o) - t.suffix(o);
        r.push({ start: s, finish: s + l }), (n.lastIndex = s + l), (o = n.exec(e));
      }
      return r;
    },
    Pn = Mn,
    Bn = (e, t) => {
      const n = W(t, t => {
        const n = Mn(e, t.pattern);
        return L(n, e => ({ ...t, ...e }));
      });
      return (e => {
        const t = (e =>
          ((e, t) => {
            const n = _.call(e, 0);
            return n.sort((e, t) => e.start - t.start), n;
          })(e))(e);
        return P(
          t,
          (e, t) => {
            const n = I(e, e => t.start >= e.start && t.finish <= e.finish);
            return z(e, e => t.start === e.start).fold(
              () => (n ? e : [...e, t]),
              n => (t.finish > e[n].finish ? [...e.slice(0, n), t] : e)
            );
          },
          []
        );
      })(n);
    },
    zn = new RegExp(jn() + '+', 'g'),
    Wn = b(0),
    Fn = sn(),
    qn = Fn.left(),
    Vn = Fn.right(),
    Un = {
      left: {
        sibling: qn.sibling,
        first: qn.first,
        slicer: e =>
          (e => {
            const t = Pn(e, Ln(jn(), Wn, Wn, C.none()));
            return C.from(t[t.length - 1]).map(e => e.start);
          })(e).map(t => [t + 1, e.length])
      },
      right: {
        sibling: Vn.sibling,
        first: Vn.first,
        slicer: e =>
          (e => {
            const t = e.search(zn);
            return t > -1 ? C.some(t) : C.none();
          })(e).map(e => [0, e])
      }
    },
    $n = (e, t, n, r, o) => {
      const s = ln(e, t, n, r)
        .map(t => {
          const n = fn(e, t.item, r.slicer, o),
            s = n.abort ? [] : $n(e, t.item, t.mode, r, o);
          return n.items.concat(s);
        })
        .getOr([]);
      return M(s, e => e.text.trim().length > 0);
    },
    Hn = (e, t, n, r) => {
      const o = ((e, t, n) => $n(e, t, Yt, Un.left, n))(e, t, r),
        s = ((e, t, n) => $n(e, t, Yt, Un.right, n))(e, n, r);
      return {
        left: o.length > 0 ? o[o.length - 1] : hn(e, t),
        right: s.length > 0 ? s[s.length - 1] : hn(e, n),
        isEmpty: 0 === o.length && 0 === s.length
      };
    },
    Jn = Nn,
    Kn = e => {
      let t = 13;
      const n = Jn.length;
      for (let r = 0; r < n; ++r) {
        const n = Jn[r];
        if (n && n.test(e)) {
          t = r;
          break;
        }
      }
      return t;
    },
    Zn = (e, t) => {
      const n = e[t],
        r = e[t + 1];
      if (t < 0 || (t > e.length - 1 && 0 !== t)) return !1;
      if (0 === n && 0 === r) return !1;
      const o = e[t + 2];
      if (0 === n && (2 === r || 1 === r || 12 === r) && 0 === o) return !1;
      const s = e[t - 1];
      return (
        ((2 !== n && 1 !== n && 12 !== r) || 0 !== r || 0 !== s) &&
        ((4 !== n && 0 !== n) || (4 !== r && 0 !== r)) &&
        ((3 !== n && 1 !== n) || 4 !== r || 4 !== s) &&
        (4 !== n || (3 !== r && 1 !== r) || 4 !== o) &&
        ((8 !== n && 9 !== n) || (0 !== r && 4 !== r && r !== An && 8 !== r && 9 !== r)) &&
        ((8 !== r && (9 !== r || (0 !== o && 4 !== o && o !== An && 8 !== o && 9 !== o))) ||
          (0 !== n && 4 !== n && n !== An && 8 !== n && 9 !== n)) &&
        (5 !== n || 6 !== r) &&
        (7 === n ||
          5 === n ||
          6 === n ||
          7 === r ||
          5 === r ||
          6 === r ||
          ((n !== An || r !== An) &&
            (11 !== r || (0 !== n && 4 !== n && n !== An && 11 !== n)) &&
            (11 !== n || (0 !== r && 4 !== r && r !== An)) &&
            12 !== n))
      );
    },
    Gn = /^\s+$/,
    Yn = Rn,
    Xn = e => 'http' === e || 'https' === e,
    Qn = (e, t) => {
      const n = ((e, t) => {
        let n;
        for (n = t; n < e.length && !Gn.test(e[n]); n++);
        return n;
      })(e, t + 1);
      return '://' ===
        e
          .slice(t + 1, n)
          .join('')
          .substr(0, 3)
        ? n
        : t;
    },
    er = (e, t, n) => ({ word: e, left: t, right: n }),
    tr = ["'", '\u2018', '\u2019'],
    nr = W(tr, e => L(['twas'], t => e + t)),
    rr = e => D(tr, e),
    or = e => {
      const { words: t, indices: n } = ((e, t, n) => {
          n = { includeWhitespace: !1, includePunctuation: !1, ...n };
          const r = L(e, t);
          return ((e, t, n, r) => {
            const o = [],
              s = [];
            let l = [];
            for (let a = 0; a < n.length; ++a)
              if ((l.push(e[a]), Zn(n, a))) {
                const n = t[a];
                if ((r.includeWhitespace || !Gn.test(n)) && (r.includePunctuation || !Yn.test(n))) {
                  const n = a - l.length + 1,
                    r = a + 1,
                    i = t.slice(n, r).join('');
                  if (Xn(i)) {
                    const n = Qn(t, a),
                      o = e.slice(r, n);
                    Array.prototype.push.apply(l, o), (a = n);
                  }
                  '.' === t[a + 1] && /^([a-zA-Z]\.)+$/.test(i + '.')
                    ? (l.push(e[a + 1]), s.push({ start: n, end: r + 1 }))
                    : s.push({ start: n, end: r }),
                    o.push(l);
                }
                l = [];
              }
            return { words: o, indices: s };
          })(
            e,
            r,
            (e => {
              const t = (e => {
                const t = {};
                return n => {
                  if (t[n]) return t[n];
                  {
                    const r = e(n);
                    return (t[n] = r), r;
                  }
                };
              })(Kn);
              return L(e, t);
            })(r),
            n
          );
        })(e.split(''), v),
        r = e.length;
      return L(t, (t, o) => {
        const s = n[o],
          l = s.start,
          a = s.end,
          i = t.join(''),
          c = l > 0 ? C.some(e.charAt(l - 1)) : C.none(),
          u = a < r ? C.some(e.charAt(a)) : C.none();
        return (e => {
          const t = (e => {
            const t = e.word;
            return t.length >= 2 && rr(t.charAt(t.length - 1)) && !rr(t.charAt(t.length - 2))
              ? (e => {
                  const t = e.word;
                  return er(t.substring(0, t.length - 1), e.left, C.some(t.charAt(t.length - 1)));
                })(e)
              : e;
          })(e);
          return (e => {
            const t = e.word,
              n = I(nr, e => t.indexOf(e) > -1) ? 2 : 1,
              r = t.substring(0, n);
            return F(r, rr) && !rr(t.charAt(n))
              ? (e => {
                  const t = e.word;
                  return er(t.substring(1), C.some(t.charAt(0)), e.right);
                })(e)
              : e;
          })(t);
        })(er(i, c, u));
      });
    },
    sr = {
      ...wt([{ aboveView: ['item'] }, { inView: ['item'] }, { belowView: ['item'] }]),
      cata: (e, t, n, r) => e.fold(t, n, r)
    },
    lr = (e, t, n) =>
      e.property().isSpecial(n.item) || e.property().isNonEditable(n.item)
        ? C.some({ item: n.item, mode: Yt })
        : e.property().isBoundary(n.item)
        ? sr.cata(
            t.assess(n.item),
            () => (n.mode !== Gt ? C.some({ item: n.item, mode: Yt }) : C.none()),
            () => C.some(n),
            () => C.none()
          )
        : C.some(n),
    ar = (e, t, n, r, o) => {
      const s = e.property().getLanguage(o.item);
      e.property().isText(o.item)
        ? t.addDetail(n(e, o.item))
        : e.property().isBoundary(o.item)
        ? sr.cata(
            r.assess(o.item),
            y,
            () => (o.mode === Xt ? t.openBoundary(s, o.item) : t.closeBoundary(s, o.item), C.some(o)),
            y
          )
        : e.property().isEmptyTag(o.item)
        ? t.addEmpty(o.item)
        : o.mode === Xt
        ? t.openInline(s, o.item)
        : t.closeInline(s, o.item);
    },
    ir = (e, t, n, r, o, s) =>
      (e.eq(t, n) ? C.some(t) : e.property().parent(t)).map(l => {
        const a = Kt(e, l).getOr(r);
        return ((e, t, n, r, o, s) => {
          const l = t =>
              !e.eq(t.item, n) ||
              (t.mode === Xt && !e.property().isText(t.item) && 0 !== e.property().children(t.item).length),
            a = (e => {
              let t = [];
              const n = [];
              let r = [],
                o = e;
              const s = e => {
                  e.each(e => {
                    t.push(e);
                  });
                },
                l = e => {
                  e.each(e => {
                    t = t.slice(0, t.length - 1);
                  });
                },
                a = () => {
                  r.length > 0 && n.push({ lang: o, details: r });
                },
                i = e => {
                  a(), (r = []), (o = e);
                },
                c = n => n.or(C.from(t[t.length - 1])).getOr(e);
              return {
                openInline: (e, t) => {
                  const n = c(e);
                  n !== o && i(n), s(e);
                },
                closeInline: (e, t) => {
                  l(e);
                },
                addDetail: e => {
                  const t = c(C.none());
                  t !== o && i(t), r.push(e);
                },
                addEmpty: e => {
                  const t = c(C.none());
                  i(t);
                },
                openBoundary: (e, t) => {
                  s(e);
                  const n = c(e);
                  i(n);
                },
                closeBoundary: (e, t) => {
                  l(e);
                  const n = c(e);
                  i(n);
                },
                done: () => (a(), n.slice(0))
              };
            })(r);
          let i = C.some({ item: t, mode: Xt }).filter(l);
          for (; i.isSome(); )
            i.each(t => ar(e, a, o, s, t)),
              (i = i
                .bind(t => lr(e, s, t))
                .filter(l)
                .bind(t => ln(e, t.item, t.mode, sn().right()))
                .filter(l));
          return e.property().isText(n) && a.addDetail(o(e, n)), a.done();
        })(e, t, n, a, o, s);
      }),
    cr = (e, t, n, r, o, s) => {
      const l = ((e, t, n) => {
        const r = ((e, t, n, r = E) => {
          const o = [t].concat(e.up().all(t)),
            s = [n].concat(e.up().all(n)),
            l = e =>
              z(e, r).fold(
                () => e,
                t => e.slice(0, t + 1)
              ),
            a = l(o),
            i = l(s),
            c = B(a, t => I(i, Ht(e, t)));
          return { firstpath: a, secondpath: i, shared: c };
        })(e, t, n);
        return r.shared.bind(t =>
          ((e, t, n, r) => {
            const o = e.property().children(t);
            if (e.eq(t, n[0])) return C.some([n[0]]);
            if (e.eq(t, r[0])) return C.some([r[0]]);
            const s = n => {
                const r = q(n),
                  s = z(r, Ht(e, t)).getOr(-1),
                  l = s < r.length - 1 ? r[s + 1] : r[s];
                return z(o, Ht(e, l));
              },
              l = s(n),
              a = s(r);
            return l.bind(e =>
              a.map(t => {
                const n = Math.min(e, t),
                  r = Math.max(e, t);
                return o.slice(n, r + 1);
              })
            );
          })(e, t, r.firstpath, r.secondpath)
        );
      })(e, t, n)
        .bind(t => {
          if (0 === t.length) return C.none();
          const n = t[0],
            l = t[t.length - 1];
          return ir(e, n, l, r, o, s);
        })
        .getOr([]);
      return ((e, t) => {
        const n = L(t, e => {
          const t = e.details,
            n = e.lang,
            r = L(t, e => e.text).join(''),
            o = L(t, e => e.item);
          return { lang: n, words: or(r), elements: o };
        });
        return { zones: n };
      })(0, l);
    },
    ur = (e, t) => (n, r) => n.eq(r, e.item) ? e : n.eq(r, t.item) ? t : mn(n, r),
    gr = () => ({ zones: [] }),
    dr = (e, t, n, r) =>
      e.property().isBoundary(t)
        ? ((e, t, n, r, o) => cr(e, t, n, r, mn, o))(e, t, t, n, r)
        : e.property().isEmptyTag(t)
        ? pr()
        : ((e, t, n, r) => {
            const o = ((e, t) => {
                const n = Hn(e, t, t, E),
                  r =
                    n.isEmpty &&
                    ((e, t) => !e.property().isText(t) && 0 === e.down().predicate(t, e.property().isText).length)(
                      e,
                      t
                    );
                return { left: n.left, right: n.right, isEmpty: r };
              })(e, t),
              s = ur(o.left, o.right);
            return o.isEmpty ? gr() : cr(e, o.left.item, o.right.item, n, s, r);
          })(e, t, n, r),
    pr = gr,
    mr = {
      af: 'Afrikaans',
      af_za: 'Afrikaans (South Africa)',
      ar: 'Arabic',
      ca: 'Catalan',
      cs: 'Czech',
      da: 'Danish',
      de: 'German',
      el: 'Greek',
      en: 'English',
      en_au: 'English (Australia)',
      en_br: 'English (United Kingdom)',
      en_ca: 'English (Canada)',
      en_gb: 'English (United Kingdom)',
      en_gb_medical: 'Medical English (UK)',
      en_uk: 'English (United Kingdom)',
      en_us: 'English (United States)',
      en_us_medical: 'Medical English (US)',
      es: 'Spanish',
      es_419: 'Spanish (Latin America)',
      es_es: 'Spanish (Spain)',
      fa: 'Farsi',
      fi: 'Finnish',
      fr: 'French',
      fr_ca: 'French (Canada)',
      he: 'Hebrew',
      hr: 'Croatian',
      hu: 'Hungarian',
      it: 'Italian',
      ja: 'Japanese',
      kk: 'Kazakh',
      ko: 'Korean',
      mi_nz: 'Maori (New Zealand)',
      nb: 'Norwegian Bokm\xe5l',
      nl: 'Dutch',
      nn: 'Norwegian Nynorsk',
      no: 'Norwegian',
      pl: 'Polish',
      pt: 'Portuguese',
      pt_br: 'Portuguese (Brazil)',
      pt_pt: 'Portuguese (Portugal)',
      ro: 'Romanian',
      ru: 'Russian',
      sk: 'Slovak',
      sl: 'Slovenian',
      sv: 'Swedish',
      sv_fi: 'Swedish (Finland)',
      th: 'Thai',
      tr: 'Turkish',
      tt: 'Tatar',
      uk: 'Ukrainian',
      zh: 'Chinese',
      zh_cn: 'Chinese (Simplified)',
      zh_tw: 'Chinese (Traditional)'
    },
    hr = e => e.replace(/-/g, '_').toLowerCase(),
    fr = e => Q(mr, hr(e)).getOrThunk(() => e.toUpperCase()),
    yr = e => (t, n) =>
      ut(t, '[lang]', e).map(e => {
        const t = we(e, 'data-mce-lang').getOrThunk(() => ye(e, 'lang')),
          r = hr(t);
        return g(n) || ee(n, r) || (n[r] = fr(r)), r;
      }),
    wr = (e => {
      let t,
        n = !1;
      return (...r) => (n || ((n = !0), (t = e.apply(null, r))), t);
    })(
      () =>
        new RegExp(
          '^' +
            /(?:[A-Za-z][A-Za-z\d.+-]{0,14}:\/\/(?:[-.~*+=!&;:'%@?^${}(),\w]+@)?|www\.|[-;:&=+$,.\w]+@)[A-Za-z\d-]+(?:\.[A-Za-z\d-]+)*(?::\d+)?(?:\/(?:[-.~*+=!;:'%@$(),\/\w]*[-~*+=%@$()\/\w])?)?(?:\?(?:[-.~*+=!&;:'%@?^${}(),\/\w]+))?(?:#(?:[-.~*+=!&;:'%@?^${}(),\/\w]+))?/g
              .source +
            '$'
        )
    ),
    br = e => {
      return C.from(((t = e), t.dom.textContent)).exists(e => {
        const t = e.trim().replace(/[\u200B\uFEFF]/g, '');
        return wr().test(t);
      });
      var t;
    },
    vr = ht(),
    xr = vr.property(),
    kr = e => ({ ...vr, property: b({ ...xr, getLanguage: yr(e) }) }),
    Tr = () => pr(),
    Sr = { assess: sr.inView },
    Er = { anything: b(Sr) },
    Or = (e, t, n, r, o, s) => {
      const l = cr(e, t, n, r, s, Er.anything()).zones;
      return 1 === l.length ? ((e, t) => (e.lang === t ? C.some(e) : C.none()))(l[0], o) : C.none();
    },
    Cr = (e, t, n, r, o) => Or(e, t, n, r, o, mn),
    _r = (e, t, n, r) =>
      e.property().isBoundary(t)
        ? Cr(e, t, t, n, r)
        : e.property().isEmptyTag(t)
        ? C.none()
        : ((e, t, n, r) => {
            const o = ((e, t) => (n, r) => {
                const o = Jt(n, r).getOr(e);
                return t !== o;
              })(n, r),
              s = Hn(e, t, t, o),
              l = ur(s.left, s.right);
            return s.isEmpty
              ? ((e, t, n, r) => {
                  const o = e.property().isText(t) ? e.property().getText(t).length : e.property().children(t).length,
                    s = $t(e, t, 0),
                    l = $t(e, t, o);
                  return Cr(e, s.element, l.element, n, r);
                })(e, t, n, r)
              : Or(e, s.left.item, s.right.item, n, r, l);
          })(e, t, n, r),
    Ar = ht(),
    Nr = e => W(e, e => ot(e, ge)),
    Rr = e => W(e, We),
    Dr = e => {
      const t = Ir(e);
      return {
        resolve: e => {
          const n = e.split(' ');
          return L(n, e => Lr(t, e)).join(' ');
        }
      };
    },
    Ir = e => e.replace(/\./g, '-'),
    Lr = (e, t) => e + '-' + t,
    jr = Dr('data.mce').resolve,
    Mr = jr('annotation'),
    Pr = jr('highlight-id'),
    Br = jr('lingo'),
    zr = (e, t) => ut(e, '.' + t),
    Wr = e => C.from(ye(e, Pr)),
    Fr = e =>
      Wr(e).fold(b([e]), t => {
        const n = je(e);
        return it(n, '.' + t);
      }),
    qr = e => {
      const t = (e => C.from(ye(e, Mr)))(e),
        n = ye(e, Br);
      return t.fold(b([e]), t => Vr(je(e), t, n));
    },
    Vr = (e, t, n) => {
      const r = it(e, `span[${Mr}]`);
      return M(r, e => {
        const r = !p(n) || ye(e, Br) === n;
        return ye(e, Mr) === t && r;
      });
    },
    Ur = b(Mr),
    $r = Dr('mce').resolve,
    Hr = jr('lingo'),
    Jr = $r('spellchecker-annotation'),
    Kr = $r('spellchecker-word'),
    Zr = $r('spellchecker-ignore'),
    Gr = $r('spellchecker-current'),
    Yr = (e, t) => C.from(ye(e, t)),
    Xr = {
      nu: () => {
        const e = xe.fromTag('span');
        var t;
        return (
          (t = e),
          j([Jr, Kr], e => {
            qt(t, e);
          }),
          fe(e, 'aria-invalid', 'spelling'),
          (e =>
            ((e, t) => ({
              element: t,
              wrap: n => {
                e.insert().append(t, n);
              }
            }))(zt, e))(e)
        );
      },
      set: (e, t, n) => {
        fe(e, 'data-mce-bogus', 1), fe(e, Ur(), n), fe(e, Hr, t);
      },
      setCurrent: e => {
        qt(e, Gr);
      },
      unSetCurrent: e => {
        Vt(e, Gr);
      },
      label: b(Jr),
      wordLabel: b(Kr),
      ignoreLabel: b(Zr),
      currentLabel: b(Gr),
      detail: e => Wr(e).bind(t => Yr(e, Ur()).bind(n => Yr(e, Hr).map(r => ({ id: t, word: n, lang: r, element: e }))))
    },
    Qr = e => ({ fold: (t, n) => n(e) }),
    eo = $r('wrap-disabled'),
    to = e => {
      const t = Fr(e);
      j(t, e => {
        Vt(e, eo);
      });
    };
  let no = 0;
  const ro = e => {
      const t = new Date().getTime(),
        n = Math.floor((window.crypto.getRandomValues(new Uint32Array(1))[0] / 4294967295) * 1e9);
      return no++, e + '_' + n + no + String(t);
    },
    oo = (e, t, n) => {
      const r = W(n, e => [e.start, e.finish]),
        o = kt(t, r, (t, n) =>
          ((e, t, n) => {
            const r = e.property().getText(t),
              o = M(
                ((e, t) => {
                  if (0 === t.length) return [e];
                  const n = P(
                      t,
                      (t, n) => {
                        if (0 === n) return t;
                        const r = e.substring(t.prev, n);
                        return { prev: n, values: t.values.concat([r]) };
                      },
                      { prev: 0, values: [] }
                    ),
                    r = t[t.length - 1];
                  return r < e.length ? n.values.concat(e.substring(r)) : n.values;
                })(r, n),
                e => e.length > 0
              );
            if (o.length <= 1) return [yt(t, 0, r.length)];
            e.property().setText(t, o[0]);
            const s = xt(
                o.slice(1),
                (t, n) => {
                  const r = e.create().text(t),
                    o = yt(r, n, n + t.length);
                  return C.some(o);
                },
                o[0].length
              ),
              l = L(s, e => e.element);
            return e.insert().afterAll(t, l), [yt(t, 0, o[0].length)].concat(s);
          })(e, t.element, n)
        );
      return L(n, t => {
        const n = ((e, t, n) => {
            const r = vt(e, t),
              o = vt(e, n);
            return r
              .bind(t => {
                const r = o.getOr(
                  ((e, t) => (e[e.length - 1] && e[e.length - 1].finish === t ? e.length + 1 : -1))(e, n)
                );
                return r > -1 ? C.some(e.slice(t, r)) : C.none();
              })
              .getOr([]);
          })(o, t.start, t.finish),
          r = L(n, e => e.element),
          s = L(r, e.property().getText).join('');
        return { elements: r, word: t.word, exact: s };
      });
    },
    so = (e, t, n, r) =>
      ((e, t, n, r) => {
        const o = Mt(e, t, r);
        return W(o, t => {
          const r = W(t, e => e.fold(It, It, e => [e], It)),
            o = L(r, e.property().getText).join(''),
            s = Bn(o, n),
            l = ((e, t) =>
              xt(t, (t, n) => {
                const r = n + e.property().getText(t).length;
                return C.from(yt(t, n, r));
              }))(e, r);
          return oo(e, l, s);
        });
      })(
        e,
        t,
        L(n, e =>
          ((e, t) => ({ word: e, pattern: t }))(
            e,
            (e => {
              const t = "((?:^'?)|(?:" + Dn() + "+'?))" + e + "((?:'?$)|(?:'?" + Dn() + '+))';
              return In(
                t,
                e => (e.length > 1 ? e[1].length : 0),
                e => (e.length > 2 ? e[2].length : 0),
                C.none()
              );
            })(e.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'))
          )
        ),
        r
      ),
    lo = ht(),
    ao = (e, t, n, r) => {
      if (I(e, e => ct(e, 'a').exists(br))) return !1;
      {
        const o = (e => {
            const t = Nr(e);
            return L(t, e => (ge(e) ? dt(e) : '')).join('');
          })(e),
          s = ((e, t, n) =>
            C.from(e[0]).bind(e => {
              const r = ((e, t, n) => _r(Ar, e, t, n))(e, t, n);
              return r.bind(e => {
                const t = e.words;
                return 1 === t.length ? C.some(t[0].word) : C.none();
              });
            }))(e, n, r);
        return o === t && Ae(s, t);
      }
    },
    io = (e, t, n, r, o) => {
      const s = ((e, t) => {
          const n = {};
          return (
            j(e, e => {
              zr(e, t.label())
                .filter($e)
                .each(e => {
                  t.detail(e).each(t => {
                    const { id: r, word: o, lang: s } = t,
                      l = Fr(e);
                    l.length > 0 && (n[r] = ((e, t, n, r) => ({ id: e, elements: t, word: n, lang: r }))(r, l, o, s));
                  });
                });
            }),
            n
          );
        })(e.elements, t),
        l = ((e, t, n) => {
          const r = X(e, v);
          return L(r, e => {
            return e.lang === n && ao(e.elements, e.word, t, e.lang)
              ? ((r = e), { fold: (e, t) => t(r) })
              : (e => ({ fold: (t, n) => t(e) }))(e);
            var r;
          });
        })(s, o, e.lang);
      j(l, e => {
        const t = e => t => {
          j(t.elements, e);
        };
        e.fold(t(r), t(n));
      });
    },
    co = (e, t, n, r) => {
      io(t, Xr, to, at, e.lang());
      const o = ((e, t, n) => ((e, t, n) => so(lo, e, t, n))(e, t, n))(t.elements, n, r),
        s = ((e, t) =>
          L(e, e =>
            ((e, t) => {
              const n = W(e.elements, e => zr(e, t).fold(b([]), V));
              return ((e, t, n) => ({ id: e, match: t, current: n }))(ro('mce-cram'), e, C.from(n[0]));
            })(e, t)
          ))(o, Xr.label());
      return W(s, n =>
        n.current.fold(
          () => {
            const r = n.match,
              o = r.word;
            if (e.ignore(r)) return [];
            const s =
              ((e, t) =>
                ((e, t, n) => {
                  if (0 === t.length) return t;
                  const r = M(t, t => e.property().isText(t) && e.property().getText(t).length > 0);
                  return L(r, t => {
                    const r = n();
                    return e.insert().before(t, r.element), r.wrap(t), r.element;
                  });
                })(zt, e, t))(
                M(r.elements, e =>
                  (ce(e) ? C.some(e) : Me(e).filter(ce)).exists(
                    e =>
                      ((e, t = !1) => {
                        return $e(e)
                          ? e.dom.isContentEditable
                          : ((n = e), ut(n, '[contenteditable]')).fold(b(t), e => 'true' === Ut(e));
                        var n;
                      })(e) && !ut(e, 'a').exists(br)
                  )
                ),
                Xr.nu
              ) || [];
            return (
              j(s, e => {
                var r, s;
                (r = e), (s = n.id), fe(r, Pr, s), qt(r, s), Xr.set(e, t.lang, o);
              }),
              s.length > 0 ? [Qr(s)] : []
            );
          },
          e => {
            return [((t = e), { fold: (e, n) => e(t) })];
            var t;
          }
        )
      );
    },
    uo = e => ((e, t, n) => ut(e, '.' + t + ':not(.' + n + ')'))(e, Xr.label(), Xr.ignoreLabel()),
    go = e => ((e, t, n) => L(e.dom.select('.' + t + ':not(.' + n + ')'), xe.fromDom))(e, Xr.label(), Xr.ignoreLabel()),
    po = e => Xr.detail(e),
    mo = Xr.label,
    ho = e => e.dispatch('SpellcheckStart'),
    fo = e => e.dispatch('SpellcheckEnd'),
    yo = (e, t, n) => e.dispatch('SpellcheckerLanguageChanged', { language: t, prevLanguage: n }),
    wo = (e, t) => e.dispatch('SpellcheckerUpdated', { spelling: t }),
    bo = 'no.language',
    vo = e => e !== bo,
    xo = b(bo),
    ko = (e, t, n) => {
      e.undoManager.transact(() => {
        const r = ((e, t) =>
          ((e, t) => {
            const n = Rr(e),
              r = Nr(e);
            return C.from(e[0]).bind(o => {
              var s;
              (s = o),
                j(n, e => {
                  Ye(s, e);
                });
              const l = C.from(r[0]);
              return (
                l.each(e => {
                  pt(e, t);
                }),
                j(r.slice(1), e => {
                  pt(e, '');
                }),
                j(e, lt),
                l
              );
            });
          })(uo(e).fold(b([]), Fr), t))(t, n);
        r.each(t => {
          const n = (e =>
            'img' === se(e)
              ? 1
              : (e => gt.getOption(e))(e).fold(
                  () => We(e).length,
                  e => e.length
                ))(t);
          e.selection.setCursorLocation(t.dom, n), e.focus();
        });
      });
    },
    To = (e, t) =>
      uo(e)
        .bind(po)
        .map(e => ({ detail: e, suggestions: t.suggestions(e.lang, e.word) })),
    So = (e, t, n) => {
      e.undoManager.transact(() => {
        (e => {
          const t = uo(e).fold(b([]), Fr);
          j(t, e => {
            Vt(e, Xr.wordLabel()), qt(e, Xr.ignoreLabel());
          });
        })(t);
      }),
        ((e, t) => {
          e.dispatch('SpellcheckerIgnore', { word: t });
        })(e, n);
    },
    Eo = (e, t, n, r, o) => {
      o.ignore(r, n),
        (e => {
          const t = uo(e).fold(b([]), qr);
          j(t, at);
        })(t),
        ((e, t, n) => {
          e.dispatch('SpellcheckerIgnoreAll', { word: t, language: n });
        })(e, n, r);
    },
    Oo = e => {
      const t = go(e);
      return $(t).bind(po);
    },
    Co = e => {
      const t = go(e);
      return (e => {
        const t = [],
          n = e => {
            t.push(e);
          };
        for (let t = 0; t < e.length; t++) e[t].each(n);
        return t;
      })(L(t, po));
    },
    _o = e => {
      const t = {};
      return (
        j(e, e => {
          t[e] = {};
        }),
        J(t)
      );
    },
    Ao = () => new Date().getTime(),
    No = (e, t = 36e5) => {
      const n = {},
        r = (e, t, r) => {
          n[e] = { result: t, timestamp: r };
        },
        o = (e, n) => e - n < t,
        s = b(n);
      return (
        l(e) &&
          (e => {
            const t = Ao();
            Z(e, (e, n) => {
              o(t, e.timestamp) && r(n, e.result, e.timestamp);
            });
          })(e),
        {
          set: r,
          get: (e, t) =>
            C.from(n[t])
              .filter(t => o(e, t.timestamp))
              .map(e => e.result),
          dump: s
        }
      );
    };
  var Ro;
  !(function (e) {
    (e.JSON = 'json'),
      (e.Blob = 'blob'),
      (e.Text = 'text'),
      (e.FormData = 'formdata'),
      (e.MultipartFormData = 'multipart/form-data');
  })(Ro || (Ro = {}));
  const Do = e => {
      let t = C.none(),
        n = [];
      const r = e => {
          o() ? s(e) : n.push(e);
        },
        o = () => t.isSome(),
        s = e => {
          t.each(t => {
            setTimeout(() => {
              e(t);
            }, 0);
          });
        };
      return (
        e(e => {
          o() || ((t = C.some(e)), j(n, s), (n = []));
        }),
        {
          get: r,
          map: e =>
            Do(t => {
              r(n => {
                t(e(n));
              });
            }),
          isReady: o
        }
      );
    },
    Io = {
      nu: Do,
      pure: e =>
        Do(t => {
          t(e);
        })
    },
    Lo = e => {
      setTimeout(() => {
        throw e;
      }, 0);
    },
    jo = e => {
      const t = t => {
        e().then(t, Lo);
      };
      return {
        map: t => jo(() => e().then(t)),
        bind: t => jo(() => e().then(e => t(e).toPromise())),
        anonBind: t => jo(() => e().then(() => t.toPromise())),
        toLazy: () => Io.nu(t),
        toCached: () => {
          let t = null;
          return jo(() => (null === t && (t = e()), t));
        },
        toPromise: e,
        get: t
      };
    },
    Mo = e => jo(() => new Promise(e)),
    Po = e => jo(() => Promise.resolve(e)),
    Bo = e => {
      const t = t => t(e),
        n = b(e),
        r = () => o,
        o = {
          tag: !0,
          inner: e,
          fold: (t, n) => n(e),
          isValue: O,
          isError: E,
          map: t => Wo.value(t(e)),
          mapError: r,
          bind: t,
          exists: t,
          forall: t,
          getOr: n,
          or: r,
          getOrThunk: n,
          orThunk: r,
          getOrDie: n,
          each: t => {
            t(e);
          },
          toOptional: () => C.some(e)
        };
      return o;
    },
    zo = e => {
      const t = () => n,
        n = {
          tag: !1,
          inner: e,
          fold: (t, n) => t(e),
          isValue: E,
          isError: O,
          map: t,
          mapError: t => Wo.error(t(e)),
          bind: t,
          exists: E,
          forall: O,
          getOr: v,
          or: v,
          getOrThunk: T,
          orThunk: T,
          getOrDie:
            ((r = String(e)),
            () => {
              throw new Error(r);
            }),
          each: y,
          toOptional: C.none
        };
      var r;
      return n;
    },
    Wo = { value: Bo, error: zo, fromOption: (e, t) => e.fold(() => zo(t), Bo) },
    Fo = e => ({
      ...e,
      toCached: () => Fo(e.toCached()),
      bindFuture: t =>
        Fo(
          e.bind(e =>
            e.fold(
              e => Po(Wo.error(e)),
              e => t(e)
            )
          )
        ),
      bindResult: t => Fo(e.map(e => e.bind(t))),
      mapResult: t => Fo(e.map(e => e.map(t))),
      mapError: t => Fo(e.map(e => e.mapError(t))),
      foldResult: (t, n) => e.map(e => e.fold(t, n)),
      withTimeout: (t, n) =>
        Fo(
          Mo(r => {
            let o = !1;
            const s = setTimeout(() => {
              (o = !0), r(Wo.error(n()));
            }, t);
            e.get(e => {
              o || (clearTimeout(s), r(e));
            });
          })
        )
    }),
    qo = e => Fo(Mo(e)),
    Vo = e => Fo(Po(Wo.value(e))),
    Uo = {
      nu: qo,
      wrap: Fo,
      pure: Vo,
      value: Vo,
      error: e => Fo(Po(Wo.error(e))),
      fromResult: e => Fo(Po(e)),
      fromFuture: e => Fo(e.map(Wo.value)),
      fromPromise: e =>
        qo(t => {
          e.then(
            e => {
              t(Wo.value(e));
            },
            e => {
              t(Wo.error(e));
            }
          );
        })
    },
    $o = e =>
      Mo(t => {
        const n = new FileReader();
        (n.onload = e => {
          const n = e.target ? e.target.result : '';
          t(n);
        }),
          n.readAsText(e);
      }),
    Ho = e => {
      try {
        const t = JSON.parse(e);
        return Wo.value(t);
      } catch (e) {
        return Wo.error('Response was not JSON.');
      }
    },
    Jo = e => Po(e.response),
    Ko = (e, t) =>
      0 === t.status
        ? 'Unknown HTTP error (possible cross-domain request)'
        : `Could not load url ${e}: ${(e =>
            '' === e.statusText ? (404 === e.status ? 'Not Found' : `Response code ${e.status}`) : e.statusText)(t)}`,
    Zo = e =>
      Uo.nu(t => {
        const n = new XMLHttpRequest();
        var r;
        n.open(
          e.method,
          ((r = e.url),
          C.from(e.query)
            .map(e => {
              const t = X(e, (e, t) => encodeURIComponent(t) + '=' + encodeURIComponent(e)),
                n = Re(r, '?') ? '&' : '?';
              return t.length > 0 ? r + n + t.join('&') : r;
            })
            .getOr(r)),
          !0
        );
        const o = (e => {
          const t =
            ((n = e.body),
            C.from(n).bind(e => {
              switch (e.type) {
                case Ro.JSON:
                  return C.some('application/json');
                case Ro.FormData:
                  return C.some('application/x-www-form-urlencoded; charset=UTF-8');
                case Ro.MultipartFormData:
                  return C.none();
                case Ro.Text:
                default:
                  return C.some('text/plain');
              }
            }));
          var n;
          const r = !0 === e.credentials ? C.some(!0) : C.none(),
            o =
              (e => {
                switch (e) {
                  case Ro.Blob:
                    return 'application/octet-stream';
                  case Ro.JSON:
                    return 'application/json, text/javascript';
                  case Ro.Text:
                    return 'text/plain';
                  default:
                    return '';
                }
              })(e.responseType) + ', */*; q=0.01',
            s = void 0 !== e.headers ? e.headers : {};
          return {
            contentType: t,
            responseType: (e => {
              switch (e) {
                case Ro.JSON:
                  return C.none();
                case Ro.Blob:
                  return C.some('blob');
                case Ro.Text:
                  return C.some('text');
                default:
                  return C.none();
              }
            })(e.responseType),
            credentials: r,
            accept: o,
            headers: s,
            progress: m(e.progress) ? C.some(e.progress) : C.none()
          };
        })(e);
        ((e, t) => {
          t.contentType.each(t => e.setRequestHeader('Content-Type', t)),
            e.setRequestHeader('Accept', t.accept),
            t.credentials.each(t => (e.withCredentials = t)),
            t.responseType.each(t => (e.responseType = t)),
            t.progress.each(t => e.upload.addEventListener('progress', e => t(e.loaded, e.total))),
            Z(t.headers, (t, n) => e.setRequestHeader(n, t));
        })(n, o);
        const s = () => {
          ((e, t, n) =>
            ((e, t) => {
              switch (e) {
                case Ro.JSON:
                  return Ho(t.response).fold(() => Jo(t), Po);
                case Ro.Blob:
                  return (e => C.from(e.response).map($o).getOr(Po('no response content')))(t);
                case Ro.Text:
                default:
                  return Jo(t);
              }
            })(t, n).map(t => ({ message: Ko(e, n), status: n.status, responseText: t })))(
            e.url,
            e.responseType,
            n
          ).get(e => t(Wo.error(e)));
        };
        var l;
        (n.onerror = s),
          (n.onload = () => {
            var r;
            0 !== n.status || ((r = e.url), Ne(r, 'file:', 0))
              ? n.status < 100 || n.status >= 400
                ? s()
                : ((e, t) => {
                    const n = e => Uo.error({ message: e, status: t.status, responseText: t.responseText });
                    switch (e) {
                      case Ro.JSON:
                        return Ho(t.response).fold(n, Uo.pure);
                      case Ro.Blob:
                      case Ro.Text:
                        return Uo.pure(t.response);
                      default:
                        return n('unknown data type');
                    }
                  })(e.responseType, n).get(t)
              : s();
          }),
          ((l = e.body),
          C.from(l).map(e =>
            e.type === Ro.JSON
              ? JSON.stringify(e.data)
              : e.type === Ro.FormData || e.type === Ro.MultipartFormData
              ? (e => {
                  const t = new FormData();
                  return (
                    Z(e, (e, n) => {
                      t.append(n, e);
                    }),
                    t
                  );
                })(e.data)
              : e.data
          )).fold(
            () => n.send(),
            e => {
              n.send(e);
            }
          );
      }),
    Go = e => ({ tag: 1, error: e }),
    Yo = (e, t) => {
      const n = -1 === e.indexOf('?') ? '?' : '&';
      return t ? e + n + 'apiKey=' + encodeURIComponent(t) : e;
    },
    Xo = e => {
      const t = e.responseText;
      return l(t) ? t : e.message;
    },
    Qo = (e, t, n = Xo) => {
      const r = (e =>
        Q(e, 'tiny-api-key')
          .orThunk(() => Q(e, 'tinymce-api-key'))
          .orThunk(() => Q(e, 'textbox-api-key'))
          .getOrUndefined())(t);
      return {
        execute: o => {
          const s = ((l = {
            url: Yo(e, r),
            body: ((a = o), { type: Ro.JSON, data: a }),
            responseType: Ro.JSON,
            credentials: !0,
            headers: t
          }),
          Zo({ ...l, method: 'get' })).mapError(n);
          var l, a;
          return Uo.wrap(s);
        },
        cancelCurrent: y
      };
    },
    es = (e, t) => {
      const n = [];
      return {
        execute: r =>
          (0 === e
            ? Uo.nu(e => {
                n.push({ resume: () => e(Wo.value(void 0)), reject: () => e(Wo.error({ tag: 0 })) });
              })
            : ((e -= 1), Uo.pure(void 0))
          ).bindFuture(() =>
            t.execute(r).map(
              t => (
                C.from(n.shift()).fold(
                  () => (e += 1),
                  e => setTimeout(e.resume, 0)
                ),
                t.mapError(Go)
              )
            )
          ),
        cancelCurrent: () => {
          for (var e; n.length; ) null === (e = n.pop()) || void 0 === e || e.reject();
        }
      };
    };
  var ts;
  !(function (e) {
    (e[(e.Error = 0)] = 'Error'), (e[(e.Value = 1)] = 'Value');
  })(ts || (ts = {}));
  const ns = (e, t, n) => (e.stype === ts.Error ? t(e.serror) : n(e.svalue)),
    rs = e => ({ stype: ts.Value, svalue: e }),
    os = e => ({ stype: ts.Error, serror: e }),
    ss = ns,
    ls = e => (l(e) && J(e).length > 100 ? ' removed due to size' : JSON.stringify(e, null, 2)),
    as = (e, t) => os([{ path: e, getErrorInfo: t }]),
    is =
      e =>
      (...t) => {
        if (0 === t.length) throw new Error("Can't merge zero objects");
        const n = {};
        for (let r = 0; r < t.length; r++) {
          const o = t[r];
          for (const t in o) ee(o, t) && (n[t] = e(n[t], o[t]));
        }
        return n;
      },
    cs = is((e, t) => (a(e) && a(t) ? cs(e, t) : t)),
    us = is((e, t) => t),
    gs = (e, t, n) => {
      switch (e.tag) {
        case 'field':
          return t(e.key, e.newKey, e.presence, e.prop);
        case 'custom':
          return n(e.newKey, e.instantiator);
      }
    },
    ds =
      ((ps = rs),
      {
        extract: (e, t) => {
          return (n = ps(t)), (r = t => ((e, t) => as(e, b(t)))(e, t)), n.stype === ts.Error ? r(n.serror) : n;
          var n, r;
        },
        toString: b('val')
      });
  var ps;
  const ms = (e, t, n, r) => r(Q(e, t).getOrThunk(() => n(e))),
    hs = (e, t, n, r, o) => {
      const s = e => o.extract(t.concat([r]), e),
        l = e =>
          e.fold(
            () => rs(C.none()),
            e => {
              const n = o.extract(t.concat([r]), e);
              return (s = n), (l = C.some), s.stype === ts.Value ? { stype: ts.Value, svalue: l(s.svalue) } : s;
              var s, l;
            }
          );
      switch (e.tag) {
        case 'required':
          return ((e, t, n, r) =>
            Q(t, n).fold(
              () =>
                ((e, t, n) => as(e, () => 'Could not find valid *required* value for "' + t + '" in ' + ls(n)))(
                  e,
                  n,
                  t
                ),
              r
            ))(t, n, r, s);
        case 'defaultedThunk':
          return ms(n, r, e.process, s);
        case 'option':
          return ((e, t, n) => n(Q(e, t)))(n, r, l);
        case 'defaultedOptionThunk':
          return ((e, t, n, r) => r(Q(e, t).map(t => (!0 === t ? n(e) : t))))(n, r, e.process, l);
        case 'mergeWithThunk':
          return ms(n, r, b({}), t => {
            const r = cs(e.process(n), t);
            return s(r);
          });
      }
    },
    fs = (e, t, n) => {
      return (
        (r = ((e, t, n) =>
          ((e, t) => (e.stype === ts.Error ? { stype: ts.Error, serror: t(e.serror) } : e))(t.extract([e], n), e => ({
            input: n,
            errors: e
          })))(e, t, n)),
        ns(r, Wo.error, Wo.value)
      );
      var r;
    },
    ys = e =>
      'Errors: \n' +
      (e => {
        const t =
          e.length > 10
            ? e.slice(0, 10).concat([{ path: [], getErrorInfo: b('... (only showing first ten failures)') }])
            : e;
        return L(t, e => 'Failed path: (' + e.path.join(' > ') + ')\n' + e.getErrorInfo());
      })(e.errors).join('\n') +
      '\n\nInput object: ' +
      ls(e.input),
    ws = e =>
      ((e, t) =>
        t(t => {
          const n = [];
          let r = 0;
          0 === e.length
            ? t([])
            : j(e, (o, s) => {
                o.get(
                  (o => s => {
                    (n[o] = s), r++, r >= e.length && t(n);
                  })(s)
                );
              });
        }))(e, Mo);
  wt([
    { bothErrors: ['error1', 'error2'] },
    { firstError: ['error1', 'value2'] },
    { secondError: ['value1', 'error2'] },
    { bothValues: ['value1', 'value2'] }
  ]);
  const bs = (e, t, n, r, o, s) => {
      const l = ((e, t, n, r, o) =>
        o
          ? { known: {}, unknown: n }
          : P(
              n,
              (n, o) => {
                const s = r(o);
                return e(t, s).fold(
                  () => ({ known: n.known, unknown: n.unknown.concat([o]) }),
                  e => {
                    const t = ((e, t) => ((e, t) => ({ [e]: t }))(e, t))(s, e);
                    return { known: { ...n.known, ...t }, unknown: n.unknown };
                  }
                );
              },
              { known: {}, unknown: [] }
            ))(t.get, o, n, r, s);
      return 0 === l.unknown.length
        ? Uo.value(l.known)
        : ((e, t, n, r, o, s) =>
            e(r, s).mapResult(
              e => (
                Z(e, (e, n) => {
                  t.set(n, e, o);
                }),
                { ...n, ...e }
              )
            ))(e, t, l.known, l.unknown, o, s);
    },
    vs = b(ds),
    xs = e =>
      ((e, t, n, r) => ({ tag: 'field', key: e, newKey: t, presence: n, prop: r }))(
        e,
        e,
        { tag: 'required', process: {} },
        vs()
      ),
    ks =
      ((Yl = [xs('language'), xs('words')]),
      {
        extract: (e, t) =>
          ((e, t, n) => {
            const r = {},
              o = [];
            for (const s of n)
              gs(
                s,
                (n, s, l, a) => {
                  const i = hs(l, e, t, n, a);
                  ss(
                    i,
                    e => {
                      o.push(...e);
                    },
                    e => {
                      r[s] = e;
                    }
                  );
                },
                (e, n) => {
                  r[e] = n(t);
                }
              );
            return o.length > 0 ? os(o) : rs(r);
          })(e, t, Yl),
        toString: () => {
          const e = L(Yl, e =>
            gs(
              e,
              (e, t, n, r) => e + ' -> ' + r.toString(),
              (e, t) => 'state(' + e + ')'
            )
          );
          return 'obj{\n' + e.join('\n') + '}';
        }
      }),
    Ts = (e, t, n, r, o) => {
      const s = ((e, t) => {
          const n = [];
          for (let r = 0; r < e.length; r += t) {
            const o = _.call(e, r, r + t);
            n.push(o);
          }
          return n;
        })(r, o),
        l = L(s, t => {
          const r = ((e, t, n) =>
            fs(e, t, n).fold(e => {
              throw new Error(ys(e));
            }, v))('ephox.spelling.service.many.ajax.service.get', ks, { language: n, words: t });
          return e.execute(r);
        }),
        a = ws(l).map(e => {
          const n = (e => {
            const t = [],
              n = [];
            return (
              j(e, e => {
                e.fold(
                  e => {
                    t.push(e);
                  },
                  e => {
                    n.push(e);
                  }
                );
              }),
              { errors: t, values: n }
            );
          })(e);
          if (n.values.length > 0) {
            const e = L(n.values, t),
              r = P(e, us, {});
            return Wo.value(r);
          }
          {
            const e = (e => {
              const t = M(e, e => 1 === e.tag);
              return L(t, e => e.error);
            })(n.errors);
            return 0 === e.length ? Wo.value({}) : Wo.error(e);
          }
        });
      return Uo.wrap(a);
    },
    Ss = (e = {}) => {
      const t = {};
      return (
        Z(e, (e, n) => {
          t[n] = No(e);
        }),
        t
      );
    },
    Es = ro('good-spelling'),
    Os = (e, t) => Q(e, t).getOrThunk(() => No()),
    Cs = e => _o(e).sort(),
    _s = e => {
      const t = e.responseText,
        n = l(t) ? t : { error: { data: null, message: e.message, type: 'Unknown' } };
      return { status: e.status, ...n };
    },
    As = { chunkSize: 1500, maxRetries: 3, maxInFlight: 8 },
    Ns = (e, t, n, r = As) => {
      var o;
      e = ((e, t) => Ne(e, t, e.length - t.length))((o = e), '/') ? ((e, t) => e.substring(0, e.length - 1))(o) : o;
      const s = Ss(n),
        l = Ss({}),
        a = e => {
          const t = ((e, t) => ({
            execute: e => {
              let n = 0;
              const o = () => (n++, t.execute(e).bind(s)),
                s = e =>
                  e.fold(
                    e =>
                      ((e, t) => !(t >= r.maxRetries) && (e.status < 400 || e.status >= 500))(e, n) ? o() : Uo.error(e),
                    Uo.pure
                  );
              return Uo.wrap(o());
            },
            cancelCurrent: t.cancelCurrent
          }))(0, e);
          return es(r.maxInFlight, t);
        },
        i = a(Qo(e + '/2/check.json', t, _s)),
        c = a(Qo(e + '/2/suggestions.json', t, _s));
      return {
        check: (e, t) => {
          const n = Cs(t),
            o = Ao(),
            a = Os(l, e),
            c = Os(s, e);
          return (
            (l[e] = a),
            (s[e] = c),
            ((e, t, n, r, o, s, l, a) => {
              const i = e => e.check;
              return bs((t, n) => Ts(e, i, r, t, l), n, o, v, s, !1).mapResult(e => {
                const n = {};
                return (
                  Z(e, (e, r) => {
                    e ? t.set(r, Es, s) : (n[r] = !1);
                  }),
                  n
                );
              });
            })(i, c, a, e, n, o, r.chunkSize)
          );
        },
        suggestions: (e, t) => {
          const n = Cs(t),
            o = Ao(),
            l = Os(s, e);
          return (
            (s[e] = l),
            ((e, t, n, r, o, s, l) => {
              const a = e => e.spell;
              return bs((t, r) => Ts(e, a, n, t, s), t, r, v, o, !1).mapResult(e => {
                j(r, n => {
                  ee(e, n) || t.set(n, Es, o);
                });
                const n = {};
                return (
                  Z(e, (e, r) => {
                    t.get(o, r).each(t => {
                      t !== Es && (n[r] = e);
                    });
                  }),
                  n
                );
              });
            })(c, l, e, n, o, r.chunkSize)
          );
        },
        cancelCurrent: () => {
          i.cancelCurrent(), c.cancelCurrent();
        },
        dumpCache: () => G(s, e => e.dump())
      };
    },
    Rs = [{ value: 'no.language', text: 'Off' }],
    Ds = e => t => t.options.get(e),
    Is = Ds('spellchecker_dialog'),
    Ls = Ds('spellchecker_language'),
    js = Ds('spellchecker_ignore_list'),
    Ms = Ds('spellchecker_handler'),
    Ps = Ds('spellchecker_rpc_url'),
    Bs = Ds('spellchecker_active'),
    zs = e => {
      const t = new RegExp('\ufeff', 'g'),
        n = new RegExp('[\u2018\u2019]', 'g');
      return e.replace(t, '').replace(n, "'");
    },
    Ws = (e, t) => ({ suggestions: e, ignore: t }),
    Fs = e => {
      const t = new Set();
      return j(e, e => t.add(e)), t;
    },
    qs = ht(),
    Vs = (e, t) => $t(qs, e, t),
    Us = e => !e.inline && e.hasPlugin('autoresize'),
    $s = (e, t) => e + t.top,
    Hs = e => e.dom.getBoundingClientRect(),
    Js = e => {
      const t = xe.fromDom(e.startContainer),
        n = xe.fromDom(e.endContainer);
      return Ks(t, e.startOffset, n, e.endOffset);
    },
    Ks = (e, t, n, r) => ({
      startContainer: e,
      startOffset: t,
      endContainer: n,
      endOffset: r,
      collapsed: Ce(e, n) && t === r
    }),
    Zs = me('img'),
    Gs = e =>
      e
        .filter(e => !e.collapsed)
        .bind(e =>
          (e => {
            const t = e.startContainer;
            if (!Ce(t, e.endContainer)) return C.none();
            if (Zs(t)) return C.some(t);
            const n = Math.min(e.startOffset, e.endOffset),
              r = Math.max(e.startOffset, e.endOffset),
              o = Fe(t, n).filter(Zs);
            return r === n || r === n + 1 ? o : C.none();
          })(e).orThunk(() =>
            (e => {
              const t = Fe(e.startContainer, e.startOffset).filter(Zs);
              return (e => ze(e.startContainer).filter(me('img')))(e)
                .or(t)
                .bind(n =>
                  (e => Be(e.endContainer).filter(me('img')))(e).bind(r => {
                    const o = Ce(n, r),
                      s = qe(e.startContainer) === e.startOffset,
                      l = 0 === e.endOffset;
                    return o && (s || t.isSome()) && l ? C.some(n) : C.none();
                  })
                );
            })(e)
          )
        ),
    Ys = e => e.slice(0).sort(),
    Xs = (e, t) => {
      const n = M(t, t => !D(e, t));
      n.length > 0 &&
        (e => {
          throw new Error('Unsupported keys for object: ' + Ys(e).join(', '));
        })(n);
    },
    Qs = (e, t) => ((e, t) => ({ ch: e, offset: t }))(e.charAt(t), t),
    el = e => (p(e) && void 0 !== e.index && e.index >= 0 ? C.some(e.index) : C.none()),
    tl = sn().left(),
    nl = sn().right(),
    rl = wt([{ abort: [] }, { kontinue: [] }, { finish: ['info'] }]),
    ol = wt([{ aborted: [] }, { edge: ['element'] }, { success: ['info'] }]),
    sl = (e, t) =>
      ((e, t) => D(['br', 'img', 'hr', 'input'], e.property().name(t)))(e, t) || e.property().isBoundary(t),
    ll = (e, t, n, r, o, s, l) => {
      const a = () => l.fold(ol.aborted, ol.edge),
        i = r => ln(e, t, n, s).fold(a, t => ll(e, t.item, t.mode, C.none(), o, s, r));
      if (sl(e, t)) return a();
      if (e.property().isText(t)) {
        const n = e.property().getText(t);
        return o(e, rl, t, n, r).fold(a, () => i(C.some(t)), ol.success);
      }
      return i(l);
    },
    al = (e, t, n) => {
      const r = t => sl(e, t);
      return ((e, t, n, r) => {
        const o = $t(e, t, n);
        return e.property().isText(t)
          ? C.none()
          : ((e, t, n, r) => nn(e, t, n, Yt, tn.left(), r))(e, o.element, e.property().isText, r).map(t =>
              ft(t, e.property().getText(t).length)
            );
      })(e, t, n, r)
        .orThunk(() =>
          ((e, t, n, r) => {
            const o = $t(e, t, n);
            return e.property().isText(t) ? C.none() : rn(e, o.element, e.property().isText, r).map(e => ft(e, 0));
          })(e, t, n, r)
        )
        .getOr(ft(t, n));
    },
    il = ((e, t) =>
      ((e, t, n) => {
        if (0 === t.length) throw new Error('You must specify at least one required field.');
        return (
          ((e, t) => {
            if (!i(t)) throw new Error('The ' + e + ' fields must be an array. Was: ' + t + '.');
            j(t, t => {
              if (!s(t)) throw new Error('The value ' + t + ' in the ' + e + ' fields was not a string.');
            });
          })('required', t),
          (e => {
            const t = Ys(e);
            B(t, (e, n) => n < t.length - 1 && e === t[n + 1]).each(e => {
              throw new Error(
                'The field: ' + e + ' occurs more than once in the combined fields: [' + t.join(', ') + '].'
              );
            });
          })(t),
          r => {
            const o = J(r);
            F(t, e => D(o, e)) ||
              ((e, t) => {
                throw new Error(
                  'All required keys (' +
                    Ys(e).join(', ') +
                    ') were not specified. Specified keys were: ' +
                    Ys(t).join(', ') +
                    '.'
                );
              })(t, o),
              e(t, o);
            const s = M(t, e => !n.validate(r[e], e));
            return (
              s.length > 0 &&
                ((e, t) => {
                  throw new Error(
                    'All values need to be of type: ' + t + '. Keys (' + Ys(e).join(', ') + ') were not.'
                  );
                })(s, n.label),
              r
            );
          }
        );
      })(e, t, { validate: m, label: 'function' }))(Xs, ['regex', 'attempt']),
    cl = (e, t, n, r) => {
      const o = al(e, t, n);
      return ll(e, o.element, Yt, C.some(o.offset), r, tl, C.none());
    },
    ul = (e, t, n, r) => {
      const o = al(e, t, n);
      return ll(e, o.element, Yt, C.some(o.offset), r, nl, C.none());
    },
    gl = (e, t, n) => {
      const r = E;
      if (!e.property().isText(t)) return C.none();
      const o = e.property().getText(t);
      return n <= o.length ? C.some(ft(t, n)) : on(e, t, e.property().isText, r).bind(t => gl(e, t, n - o.length));
    },
    dl = {
      previousChar: (e, t) => {
        for (let n = t.getOr(e.length) - 1; n >= 0; n--) if ('\ufeff' !== e.charAt(n)) return C.some(Qs(e, n));
        return C.none();
      },
      nextChar: (e, t) => {
        for (let n = t.getOr(0) + 1; n < e.length; n++) if ('\ufeff' !== e.charAt(n)) return C.some(Qs(e, n));
        return C.none();
      },
      repeatLeft: cl,
      repeatRight: ul,
      expandLeft: (e, t, n, r) => {
        const o = il(r);
        return cl(e, t, n, (e, t, n, r, s) => {
          const l = s.getOr(r.length);
          return ((e, t) => {
            t.lastIndex = -1;
            const n = q(e).join('');
            return el(n.match(t)).map(e => n.length - 1 - e);
          })(r.substring(0, l), o.regex()).fold(
            () => t.kontinue(),
            e => o.attempt(t, n, r, e)
          );
        });
      },
      expandRight: (e, t, n, r) => {
        const o = il(r);
        return ul(e, t, n, (e, t, n, r, s) => {
          const l = s.getOr(0);
          var a, i;
          return ((a = r.substring(l)), ((i = o.regex()).lastIndex = -1), el(a.match(i))).fold(
            () => t.kontinue(),
            e => o.attempt(t, n, r, l + e)
          );
        });
      },
      scanRight: gl
    },
    pl = ht(),
    ml = (e, t) => {
      const n = ft(e, t);
      return ge(e) ? ((e, t) => dl.scanRight(pl, e, t))(e, t).getOr(n) : n;
    },
    hl = e => ge(e) || 'br' === se(e),
    fl = (e, t, n, r) => {
      return (hl(n.startContainer) && hl(n.endContainer)) ||
        ((o = C.some(n)), Gs(o).map(e => ({ image: () => e }))).isSome()
        ? ((e, t, n, r) => {
            const o = t();
            return (
              e.hasFocus() &&
                !e.removed &&
                ((e, t, n) => {
                  const r = e.dom.createRng();
                  r.setStart(t.startContainer.dom, t.startOffset),
                    r.setEnd(t.endContainer.dom, t.endOffset),
                    e.selection.setRng(r, n);
                })(
                  e,
                  (e => {
                    const t = ml(e.startContainer, e.startOffset),
                      n = ml(e.endContainer, e.endOffset);
                    return Ks(t.element, t.offset, n.element, n.offset);
                  })(n),
                  r
                ),
              o
            );
          })(e, t, n, r)
        : ((e, t) => {
            if (e.hasFocus()) {
              const n = e.selection.getBookmark(),
                r = t();
              return e.selection.moveToBookmark(n), r;
            }
            return t();
          })(e, t);
      var o;
    },
    yl = (e, t) =>
      Fe(e, t).fold(
        () => ({ element: e, offset: t }),
        e => {
          const t = We(e);
          return t.length > 0 ? yl(e, t.length - 1) : { element: e, offset: ge(e) ? dt(e).length : 0 };
        }
      ),
    wl = e =>
      Fe(e.endContainer, e.endOffset - 1)
        .filter(t => {
          return (
            (o = t),
            (s = e.startContainer),
            (n = o),
            (r = k(Ce, s)),
            ((e, t) => {
              const n = e => {
                for (let r = 0; r < e.childNodes.length; r++) {
                  const o = xe.fromDom(e.childNodes[r]);
                  if (t(o)) return C.some(o);
                  const s = n(e.childNodes[r]);
                  if (s.isSome()) return s;
                }
                return C.none();
              };
              return n(e.dom);
            })(n, r).isSome()
          );
          var n, r, o, s;
        })
        .fold(
          () => Vs(e.endContainer, e.endOffset),
          () => yl(e.endContainer, e.endOffset - 1)
        ),
    bl = (e, t) => {
      const n = (e => Js(e.selection.getRng()))(e),
        r = e.selection.isForward(),
        o = (e => {
          if (
            (e => {
              const t = ((e, t) => {
                const n = We(e);
                return n.length > 0 && t < n.length ? Ve(n[t], 0) : Ve(e, t);
              })(e.startContainer, e.startOffset).element;
              return (
                ue(t) &&
                'false' === ye(t, 'contenteditable') &&
                Ce(e.startContainer, e.endContainer) &&
                e.startOffset === e.endOffset - 1
              );
            })(e)
          )
            return e;
          {
            const t = wl(e),
              n = Vs(e.startContainer, e.startOffset);
            return Ks(n.element, n.offset, t.element, t.offset);
          }
        })(n);
      return fl(e, t, o, r);
    },
    vl = e => {
      let t = [];
      return {
        bind: e => {
          if (void 0 === e) throw new Error('Event bind error: undefined handler');
          t.push(e);
        },
        unbind: e => {
          t = M(t, t => t !== e);
        },
        trigger: (...n) => {
          const r = {};
          j(e, (e, t) => {
            r[e] = n[t];
          }),
            j(t, e => {
              e(r);
            });
        }
      };
    },
    xl = e => {
      const t = xe.fromDom(
          (e => {
            if (p(e.target)) {
              const t = xe.fromDom(e.target);
              if (ue(t) && p(t.dom.shadowRoot) && e.composed && e.composedPath) {
                const t = e.composedPath();
                if (t) return $(t);
              }
            }
            return C.from(e.target);
          })(e).getOr(e.target)
        ),
        n = () => e.stopPropagation(),
        r = () => e.preventDefault(),
        o = w(r, n);
      return ((e, t, n, r, o, s, l) => ({ target: e, x: t, y: n, stop: r, prevent: o, kill: s, raw: l }))(
        t,
        e.clientX,
        e.clientY,
        n,
        r,
        o,
        e
      );
    },
    kl = (e, t, n, r, o) => {
      const s = ((e, t) => n => {
        e(n) && t(xl(n));
      })(n, r);
      return e.dom.addEventListener(t, s, o), { unbind: k(Tl, e, t, s, o) };
    },
    Tl = (e, t, n, r) => {
      e.dom.removeEventListener(t, n, r);
    },
    Sl = O,
    El = (e, t, n) => ((e, t, n, r) => kl(e, t, n, r, !1))(e, t, Sl, n),
    Ol = e => {
      const t = (() => {
          let e = !1;
          return {
            lock: () => (e ? C.none() : ((e = !0), C.some(void 0))),
            unlock: () => {
              if (!e) throw new Error('Double unlock');
              e = !1;
            },
            runIfUnlocked: t => {
              e || t();
            }
          };
        })(),
        n =
          ((r = { lookup: vl(['element']), scroll: vl([]), change: vl([]) }),
          { registry: G(r, e => ({ bind: e.bind, unbind: e.unbind })), trigger: G(r, e => e.trigger) });
      var r;
      const o = () => {
          const r = Js(e.selection.getRng());
          t.runIfUnlocked(() => n.trigger.lookup(r.startContainer));
        },
        s = ((e, t) => {
          let n = null;
          const r = () => {
            c(n) || (clearTimeout(n), (n = null));
          };
          return {
            cancel: r,
            throttle: (...t) => {
              r(),
                (n = setTimeout(() => {
                  (n = null), e.apply(null, t);
                }, 1e3));
            }
          };
        })(() => {
          t.runIfUnlocked(() => n.trigger.scroll());
        }),
        l = ((e, r) => {
          let o = !1,
            s = !1;
          const l = () => {
            (o = !0),
              setTimeout(() => {
                t.runIfUnlocked(() => n.trigger.change());
              }, 0),
              setTimeout(() => {
                (o = !1), s && ((s = !1), l());
              }, 1e3);
          };
          return () => {
            o ? (s = !0) : l();
          };
        })(),
        a = t => {
          e.composing ||
            e.removed ||
            (!(e => 32 === (e.which || e.keyCode))(t) && !(e => 13 === (e.which || e.keyCode))(t)) ||
            o();
        };
      return (
        e.on('init', () => {
          let r = xe.fromDom(e.getBody());
          const i =
              t =>
              (...n) => {
                e.mode.isReadOnly() || t(...n);
              },
            c = e.getDoc(),
            u = e.inline ? 'ResizeWindow' : 'ResizeEditor',
            g = El(xe.fromDom(document), 'scroll', i(s.throttle)),
            d = document === c ? C.none() : C.from(El(xe.fromDom(c), 'scroll', i(s.throttle))),
            p =
              ((m = xe.fromDom(document)),
              (h = 'scroll'),
              (f = i(t => {
                ue(t.target) &&
                  ((e, t) => {
                    const n = e.dom,
                      r = t.dom;
                    return n !== r && n.contains(r);
                  })(t.target, xe.fromDom(e.getContentAreaContainer())) &&
                  s.throttle();
              })),
              ((e, t, n, r) => kl(e, t, n, r, !0))(m, h, Sl, f));
          var m, h, f;
          i(s.throttle)(),
            e.on(u, i(s.throttle)),
            e.on('keyup', i(a)),
            e.on(
              'NodeChange',
              i(o => {
                if (e.composing || o.selectionChange) return;
                const s = xe.fromDom(o.element);
                Ce(r, s) || (t.runIfUnlocked(() => n.trigger.lookup(r)), (r = s));
              })
            ),
            e.on('SetContent', i(l)),
            e.on('compositionend', i(o)),
            e.on(
              'input',
              i(e => {
                const t = e.inputType;
                ('insertFromPaste' !== t && 'insertFromDrop' !== t && 'insertReplacementText' !== t) || l();
              })
            ),
            e.on('remove', () => {
              s.cancel(), g.unbind(), d.each(e => e.unbind()), p.unbind();
            });
        }),
        {
          events: n.registry,
          transact: e => {
            t.lock().fold(
              () => console.warn('TinyMCE spellchecker state error'),
              () =>
                e.get(() => {
                  l(), t.unlock();
                })
            );
          }
        }
      );
    },
    Cl = mo(),
    _l = e => ((e, t) => Ft(e) && e.dom.classList.contains(t))(e, Cl),
    Al = e => {
      let t = e;
      return {
        get: () => t,
        set: e => {
          t = e;
        }
      };
    },
    Nl = (e, t, n) => {
      const r = J(n);
      j(r, r => {
        const o = n[r];
        u(o) ? o || e.add(t, r, C.none()) : e.add(t, r, C.some(o));
      });
    },
    Rl = e => e.fold(E, e => !e.ignore),
    Dl = (e, t, n) => {
      const r = { ignore: E, lang: b(n) },
        o = L(t, e => e.word),
        s = M(o, (e, t) =>
          ((e, t) => {
            const n = R(e, t);
            return -1 === n ? C.none() : C.some(n);
          })(o, e)
            .filter(e => e === t)
            .isSome()
        );
      co(r, e, s, E);
    },
    Il = (e, t, n) => M(e, e => !t.isWordIgnored(n, e)),
    Ll = (e, t) => {
      const n = J(t);
      return M(e, e => !D(n, e));
    },
    jl = (e, t, n, r) => {
      const o = {},
        s = {};
      return L(n, n =>
        (n => {
          const l = n.lang,
            a = L(n.words, e => zs(e.word)),
            i = _o(a),
            c = Il(i, r, l),
            u = ((e, t, n) => {
              const r = e.getCorrect(t);
              return M(n, n => (e.get(t, n).isNone() || e.suggestions(t, n).isNone()) && !D(r, n));
            })(e, l, c),
            g = Q(s, l).getOrThunk(() => {
              const e = {};
              return (s[l] = e), e;
            }),
            { pass: d, fail: p } = ((e, t) => {
              const n = [],
                r = [];
              for (let t = 0, s = e.length; t < s; t++) {
                const s = e[t];
                ((o = s), Q(g, o).isSome() ? n : r).push(s);
              }
              var o;
              return { pass: n, fail: r };
            })(u),
            m = 0 !== p.length ? t(p, l) : Po(C.none()),
            h = ro('spellingRequest');
          return (
            (o[h] = m),
            j(p, e => (g[e] = h)),
            m.map(t =>
              t.fold(
                () => ({ spelling: {}, awaitingWords: d }),
                t => {
                  const n = Ll(p, t);
                  return e.addCorrect(l, n), Nl(e, l, t), { spelling: t, awaitingWords: d };
                }
              )
            )
          );
        })(n).bind(t =>
          ((e, { spelling: t, awaitingWords: n }) => {
            const r = H(
              L(n, t => {
                const n = s[e][t];
                return o[n];
              })
            );
            if (0 !== r.length) {
              const e = e =>
                j(n, n =>
                  Q(e, n).each(e => {
                    t[n] = e;
                  })
                );
              return ws(r).bind(n => (j(n, t => t.each(e)), Po(t)));
            }
            return Po(t);
          })(n.lang, t).map(t =>
            ((t, n) => {
              const r = t.lang,
                o = J(n),
                s = ((e, t, n) =>
                  M(n, n => {
                    const r = e.get(t, n);
                    return Rl(r);
                  }))(e, r, o);
              return {
                zone: t,
                words: M(t.words, e => {
                  const t = zs(e.word);
                  return D(s, t);
                })
              };
            })(n, t)
          )
        )
      );
    },
    Ml = (e, t, n) => {
      const r = (e, t, n) => {
          e(() => {
            Dl(t.zone, t.words, n);
          });
        },
        o = o => (s, l, a, i, c) => {
          const u = l.zones;
          ((e, n, r, o) => {
            if (0 === e.length) return void n(!0, y);
            const s = Al(!1),
              l = () => {
                t.cancelCurrent(), s.set(!0);
              };
            let a = 0;
            const i = new Map();
            j(e, (t, c) => {
              t.get(t => {
                if ((i.set(c, t), n(!1, l), r)) for (; i.has(a); ) s.get() || o(i.get(a)), (a += 1);
                else s.get() || o(t);
                s.get() || n(e.length === i.size, l);
              });
            }),
              n(!1, l);
          })(jl(e, o, u, n), i, c, e => r(s, e, a));
        };
      return {
        local: (t, n, o, s) => {
          const l = (t =>
            L(t, t => {
              const n = ((e, t, n) =>
                M(n, n => {
                  const r = e.get(t, n.word);
                  return Rl(r);
                }))(e, t.lang, t.words);
              return { zone: t, words: n };
            }))(n.zones);
          j(l, e => r(t, e, o)), s(!0, y);
        },
        remote: o(t.suggestions),
        check: o(t.check),
        fetch: r =>
          ((e, t, n, r) => {
            const o = {};
            j(n, e => {
              const { word: t, lang: n } = e.detail,
                r = Q(o, n).fold(
                  () => [e],
                  n => (I(n, ({ detail: e }) => t === e.word) || n.push(e), n)
                );
              o[n] = r;
            });
            const s = X(o, (e, n) => {
              const o = L(e, ({ detail: e }) => zs(e.word)),
                s = Il(o, r, n);
              if (0 !== s.length) return t(s, n).map(e => ({ spelling: e, language: n, validWords: s }));
              {
                const e = C.none();
                return Po({ spelling: e, language: n, validWords: s });
              }
            });
            return ws(s).map(t =>
              L(t, ({ spelling: t, language: n, validWords: r }) =>
                t.fold(
                  () => ({ spelling: {}, language: n }),
                  t => {
                    const o = Ll(r, t);
                    return e.addCorrect(n, o), Nl(e, n, t), { spelling: t, language: n };
                  }
                )
              )
            );
          })(e, t.suggestions, r, n)
      };
    },
    Pl = (e, t, n) => {
      const r = Al(t),
        o = (() => {
          let e = [],
            t = !1;
          const n = () => {
            (t = !0),
              C.from(e.shift()).fold(
                () => {
                  t = !1;
                },
                e => {
                  e.f(e.area, n);
                }
              );
          };
          return {
            enqueue: (r, o) => {
              e.push(((e, t) => ({ area: e, f: t }))(r, o)), t || n();
            },
            destroy: () => {
              e = [];
            }
          };
        })(),
        s = (t, o, s, l, a, i) => {
          const c = i ? { assess: e => sr.inView(e) } : n(),
            u = ((t, n, o) => {
              switch (t.tag) {
                case 0:
                  return (s = t.element), $e(s) ? ((e, t, n, r) => dr(kr(e), t, n, r))(e, s, r.get(), c) : Tr();
                case 1:
                  return ((t, n, o, s) =>
                    $e(t) && $e(o)
                      ? ((e, t, n, r, o, s, l) =>
                          ((e, t, n, r, o, s, l) => {
                            const a = $t(e, t, n),
                              i = $t(e, r, o);
                            return e.eq(a.element, i.element)
                              ? dr(e, a.element, s, l)
                              : ((e, t, n, r, o) => {
                                  const s = Hn(e, t, n, E),
                                    l = ur(s.left, s.right);
                                  return cr(e, s.left.item, s.right.item, r, l, o);
                                })(e, a.element, i.element, s, l);
                          })(kr(e), t, n, r, o, s, l))(e, t, n, o, s, r.get(), c)
                      : Tr())(t.start, t.sOffset, t.finish, t.fOffset);
              }
              var s;
            })(s);
          o(t, u, r.get(), l, a);
        };
      return {
        run: (e, t, n, r, o, l) => {
          s(e, t, n, r, o, l);
        },
        setLang: r.set,
        schedule: (e, t, n, r, l) => {
          o.enqueue(n, (n, o) => {
            l()
              ? o()
              : s(
                  e,
                  t,
                  n,
                  (e, t) => {
                    l() ? (t(), o()) : e && o();
                  },
                  r,
                  !1
                );
          });
        },
        destroy: () => {
          o.destroy();
        }
      };
    },
    Bl = e => {
      let t = C.none(),
        n = [];
      const r = e => {
          o() ? s(e) : n.push(e);
        },
        o = () => t.isSome(),
        s = e => {
          t.each(t => {
            e(t);
          });
        };
      return (
        e(e => {
          var r;
          o() || ((t = C.some(e)), (r = n), setTimeout(() => j(r, s), 0), (n = []));
        }),
        {
          get: r,
          getSync: () => t.fold(() => Wo.error(Mo(r)), Wo.value),
          map: e =>
            Bl(t => {
              r(n => {
                t(e(n));
              });
            }),
          isReady: o
        }
      );
    },
    zl = {
      nu: Bl,
      pure: e =>
        Bl(t => {
          t(e);
        })
    },
    Wl = (e, t, n) => {
      const r = Ns(
          t,
          (e => {
            const t = (e => {
              var t;
              return null !== (t = e.options.get('spellchecker_api_key')) && void 0 !== t
                ? t
                : e.options.get('api_key');
            })(e);
            return d(t) ? {} : { 'tiny-api-key': t };
          })(e),
          void 0,
          n
        ),
        o = {},
        a = t => {
          const n = (e => {
            const t = M(e, l),
              n = L(t, e => {
                var t;
                return null === (t = e.error) || void 0 === t ? void 0 : t.message;
              }),
              r = M(n, s),
              o = _o(r);
            if ((o.sort(), o.length > 0)) {
              const e = (e => I(e, e => 0 === e.status))(t)
                ? 'Unable to communicate with the spelling service'
                : 'Error response from the spelling service';
              return e + ' - ' + o.join(', ');
            }
            return 'An unexpected error occurred with the spelling service';
          })(t);
          return (
            console.error(n),
            ((e, t) => {
              e.dispatch('SpellcheckError', t);
            })(e, { message: n }),
            t
          );
        },
        i = (e, t) => (e ? t().map(e => e.mapError(a).toOptional()) : Po(C.none())),
        c = (e, t) =>
          Q(o, e)
            .getOrThunk(() => {
              const t = (e =>
                zl.nu(t => {
                  r.check(e, ['startup']).get(e => {
                    t(e.isValue()), e.mapError(a);
                  });
                }))(e);
              return (o[e] = t), t;
            })
            .getSync()
            .fold(
              e => e.bind(e => i(e, t)),
              e => i(e, t)
            );
      return {
        check: (e, t) => c(t, () => r.check(t, e)),
        suggestions: (e, t) => c(t, () => r.suggestions(t, e)),
        state: () => r.dumpCache(),
        cancelCurrent: r.cancelCurrent
      };
    },
    Fl = (e, t, n, r, o, s, l) => {
      const a = (e => {
          const t = () => ((e => !e.inline && !Us(e))(e) ? e.getWin() : window),
            n = () => {
              if (Us(e)) {
                const t = (e.inline ? e.getBody() : e.getContentAreaContainer()).getBoundingClientRect();
                return e => {
                  const n = Hs(e);
                  return { ...n, top: $s(n.top, t), bottom: $s(n.bottom, t) };
                };
              }
              return Hs;
            };
          return {
            sections: () =>
              (() => {
                const r = e.getBody();
                if (!r) return [];
                const o = t(),
                  s = n(),
                  l = o.innerHeight,
                  a = xe.fromDom(r),
                  i = We(a);
                return z(i, e => {
                  if (!ue(e)) return !1;
                  const t = s(e);
                  return t.top < l && t.bottom > 0;
                })
                  .map(e => {
                    const t = z(i.slice(e + 1), e => {
                      if (!ue(e)) return !1;
                      const t = s(e);
                      return !(t.top < l && t.bottom > 0);
                    })
                      .map(t => e + 1 + t)
                      .getOr(i.length);
                    return i.slice(e, t);
                  })
                  .getOr([a]);
              })(),
            viewport: () => {
              const e = t(),
                r = e ? e.innerHeight : 0,
                o = n();
              return {
                assess: e => {
                  return ue(e)
                    ? ((t = o(e)), (n = r), t.bottom < 0 ? sr.aboveView : t.top > n ? sr.belowView : sr.inView)(e)
                    : sr.inView(e);
                  var t, n;
                }
              };
            }
          };
        })(e),
        i = t => bl(e, t),
        c = (e => {
          const t = e.gaol,
            n = e.editor,
            r = e.language,
            o = C.from(Ms(n)).getOrThunk(() => Wl(n, e.url, e.serverSettings)),
            s = Pl(e => Ce(e, xe.fromDom(n.getBody())), r, e.viewable.viewport),
            l = Ml(e.cache, o, e.ignoreList),
            a = () => n.removed || !vo(t.spelling().get()),
            i = () => {
              (e => {
                const t = n.dom.select('span.mce-spellchecker-word');
                j(t, e => {
                  (e => {
                    const t = e.parentNode,
                      n = e.childNodes;
                    if (t) {
                      for (; n.length > 0; ) t.insertBefore(n[0], e);
                      t.removeChild(e);
                    }
                  })(e);
                });
              })();
            };
          return (
            e.editor.on('remove', () => {
              s.destroy();
            }),
            {
              run: (e, n) => {
                const r = t.spelling().get();
                vo(r) && (s.setLang(r), s.run(e, l.local, n, y, !1, !1), s.schedule(e, l.remote, n, !1, a));
              },
              fetch: l.fetch,
              check: (e, n, r, o, a) => {
                s.setLang(t.nonOffSpelling()), s.run(e, l.local, n, y, o, a), s.run(e, l.check, n, r, o, a);
              },
              refresh: () => {
                const n = t.spelling().get();
                (vo(n) && e.asYouType) || i();
              },
              clear: i,
              state: o.state
            }
          );
        })({
          editor: e,
          gaol: r,
          viewable: a,
          cache: n,
          url: t,
          language: r.spelling().get(),
          asYouType: o,
          serverSettings: s,
          ignoreList: l
        });
      e.on('init', () => {
        const t = e.getBody(),
          n = xe.fromDom(t);
        fe(n, 'spellcheck', !1), c.refresh();
      }),
        e.on('remove', () => {
          const t = e.getBody(),
            r = xe.fromDom(t);
          be(r, 'spellcheck'), n.destroy();
        });
      const u = (e, t, n, r) => {
          const o = _l(e) ? Vs(e, t) : ft(e, t),
            s = _l(n) ? Vs(n, r) : ft(n, r);
          return ((e, t, n, r) => {
            const o = ((e, t, n, r) => {
                const o = ((e, t, n, r) => {
                    const o = je(e).dom.createRange();
                    return o.setStart(e.dom, t), o.setEnd(n.dom, r), o;
                  })(e, t, n, r),
                  s = Ce(e, n) && t === r;
                return o.collapsed && !s;
              })(n, r, e, t),
              s = o ? ft(e, t) : ft(n, r),
              l = o ? ft(n, r) : ft(e, t);
            return { tag: 1, start: s.element, sOffset: s.offset, finish: l.element, fOffset: l.offset };
          })(o.element, o.offset, s.element, s.offset);
        },
        g = e => {
          const t = e[0],
            n = e[e.length - 1],
            r = qe(n);
          return u(t, 0, n, r);
        },
        d = () => {
          const e = a.sections();
          if (e.length > 0) {
            const t = g(e);
            c.run(i, t);
          }
        },
        p = o ? C.some(Ol(e)) : C.none();
      p.each(e => {
        e.events.lookup.bind(e => {
          const t = { tag: 0, element: e.element };
          c.run(i, t);
        }),
          e.events.scroll.bind(d),
          e.events.change.bind(d);
      });
      const m = p.fold(
        () => e => e.get(y),
        e => e.transact
      );
      return {
        scanView: d,
        scanRange: (e, t, n, r) => {
          const o = u(e, t, n, r);
          c.run(i, o);
        },
        checkDocument: (t, n) => {
          const r = xe.fromDom(e.getBody()),
            o = We(r);
          if (o.length > 0) {
            const e = g(o);
            c.check(i, e, t, n, !0);
          }
        },
        fetch: c.fetch,
        clear: c.clear,
        transact: m
      };
    },
    ql = (() => {
      try {
        const e = te.localStorage,
          t = '__storage_test__';
        return e.setItem(t, t), e.removeItem(t), C.some(e);
      } catch (e) {
        return C.none();
      }
    })().fold(
      () => {
        const e = {};
        return {
          getItem: t => e[t],
          setItem: (t, n) => {
            e[t] = n;
          }
        };
      },
      e => ({
        getItem: t => e.getItem('mce.' + t),
        setItem: (t, n) => {
          e.setItem('mce.' + t, n);
        }
      })
    ),
    Vl = e => {
      const t = ((e, t) => {
          const n = (e => C.from(ql.getItem(e)))(e).map(JSON.parse);
          return n.getOr(t);
        })('spelling', e),
        n = hr(t),
        r = Al(n),
        o = Al('no.language' === n ? 'en_us' : n),
        s = r.set,
        l = r.get,
        a = {
          setAndCache: (e, t) => {
            ((e, t) => {
              e.options.set('spellchecker_language', t);
            })(e, t),
              s(t),
              ((e, t) => {
                const n = JSON.stringify(t);
                ql.setItem('spelling', n);
              })(0, t),
              vo(t) && o.set(t);
          },
          set: s,
          get: l
        };
      return { spelling: b(a), nonOffSpelling: o.get, setNonOffSpelling: o.set };
    },
    Ul = 'SpellcheckStart SpellcheckEnd',
    $l = () => {
      const e = (e => {
        const t = Al(C.none()),
          n = () => t.get().each(e);
        return {
          clear: () => {
            n(), t.set(C.none());
          },
          isSet: () => t.get().isSome(),
          get: () => t.get(),
          set: e => {
            n(), t.set(C.some(e));
          }
        };
      })(y);
      return { ...e, on: t => e.get().each(t) };
    },
    Hl = [{ text: 'No suggestions found', value: 'No suggestions found' }],
    Jl = (e, t) => {
      t.setEnabled('next', e.hasNext()), t.setEnabled('previous', e.hasPrevious());
    },
    Kl = (e, t, n, r) => ({
      title: 'Spellcheck',
      body: {
        type: 'panel',
        items: [
          {
            type: 'label',
            label: 'Misspelled word',
            items: [
              {
                type: 'bar',
                items: [
                  { type: 'input', name: 'textlabel', maximized: !0 },
                  {
                    type: 'bar',
                    items: [
                      {
                        type: 'button',
                        name: 'previous',
                        text: 'Previous',
                        icon: 'action-prev',
                        borderless: !0,
                        enabled: e.hasPrevious()
                      },
                      {
                        type: 'button',
                        name: 'next',
                        text: 'Next',
                        icon: 'action-next',
                        borderless: !0,
                        enabled: e.hasNext()
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            type: 'selectbox',
            name: 'suggestions',
            label: 'Suggestions',
            size: 6,
            enabled: t.length > 0,
            items: t.length > 0 ? t : Hl
          }
        ]
      },
      initialData: { textlabel: n, suggestions: r.length > 0 ? r[0] : '' },
      onClose: e.onClose,
      onChange: (e, t) => {
        'textlabel' === t.name && e.setEnabled('accept', e.getData().textlabel !== n);
      },
      onAction: (t, r) => {
        switch (r.name) {
          case 'accept':
            e.replace(t, n);
            break;
          case 'ignore':
            e.ignore(t);
            break;
          case 'ignoreall':
            e.ignoreAll(t);
            break;
          case 'next':
            e.next(t);
            break;
          case 'previous':
            e.previous(t);
        }
        Jl(e, t), t.focus('textlabel');
      },
      buttons: [
        { type: 'custom', primary: !0, name: 'accept', text: 'Accept', enabled: t.length > 0 },
        { type: 'custom', name: 'ignore', text: 'Ignore' },
        { type: 'custom', name: 'ignoreall', text: 'Ignore all' }
      ]
    }),
    Zl = (e, t, n) => {
      const r = L(t, e => ({ text: e, value: e }));
      return Kl(e, r, n.word, t);
    },
    Gl = (e, t, n, r, o) => {
      const s = { inline: 'toolbar' },
        l = (() => {
          const e = { words: [], index: -1, current: C.none() },
            t = (t, r) => {
              ((e, t) => z(e, e => e.id === t))(t, r).fold(n, n =>
                ((t, n) => {
                  (e.words = t), (e.index = n), (e.current = U(t, n));
                })(t, n)
              );
            },
            n = () => {
              (e.words = []), (e.index = -1), (e.current = C.none());
            };
          return {
            getNextWord: (t, n) => {
              const r = e.words;
              if (r.length <= 1) return C.none();
              {
                const o = e.index,
                  s = r[o],
                  l = q(r.slice(0, o)),
                  a = r.slice(o + 1),
                  i = 0 === t ? a.concat(l) : l.concat(a);
                return n ? B(i, e => e.word !== s.word || e.lang !== s.lang) : $(i);
              }
            },
            hasNext: () => e.words.length > 1 && e.index < e.words.length - 1,
            hasPrevious: () => e.words.length > 1 && e.index > 0,
            getCurrent: () => e.current,
            setCurrent: t,
            refreshCurrent: n => {
              e.current.each(e => t(n, e.id));
            },
            clear: n
          };
        })(),
        a = e => To(e.element, t),
        i = () => l.getCurrent().bind(a),
        c = Al(!0),
        u = $l(),
        g = $l(),
        d = {
          replace: (t, n) => {
            const r = t.getData(),
              o = r.textlabel !== n ? r.textlabel : r.suggestions;
            w(
              t,
              C.some(t => ko(e, t.detail.element, o)),
              0
            );
          },
          ignore: t => {
            w(
              t,
              C.some(t => So(e, t.detail.element, t.detail.word)),
              0
            );
          },
          ignoreAll: n => {
            w(
              n,
              C.some(n => Eo(e, n.detail.element, n.detail.word, n.detail.lang, t)),
              0,
              !0
            );
          },
          onClose: () => {
            u.on(S), u.clear(), g.clear(), c.set(!0), o.cleanUpAndRescan(), l.clear();
          },
          next: e => {
            w(e, C.none(), 0);
          },
          previous: e => {
            w(e, C.none(), 1);
          },
          hasNext: l.hasNext,
          hasPrevious: l.hasPrevious
        },
        p = () => {
          const t = e.translate('No misspellings found.');
          e.notificationManager.open({ text: t, type: 'info', timeout: 3e3 });
        },
        m = (e, t) => {
          e.redial(t), e.focus('textlabel');
        },
        h = Al(y),
        f = Al(!1),
        w = (t, n, r, s = !1) => {
          const u = ((t, n) =>
            l
              .getCurrent()
              .fold(
                () => Oo(e),
                () => l.getNextWord(t, n)
              )
              .map(e => e.id))(r, s);
          i().each(n.getOr(y)),
            (t => {
              const n = Co(e);
              return t.bind(e => (l.setCurrent(n, e), i()));
            })(u).fold(
              () => {
                f.get()
                  ? (t.block('Finding word suggestions'),
                    h.set(() => {
                      t.unblock(), w(t, n, 0, s);
                    }))
                  : (n.fold(p, t =>
                      (() => {
                        const t = e.translate('Spell check complete.');
                        e.notificationManager.open({ text: t, type: 'success', timeout: 3e3 });
                      })()
                    ),
                    t.close());
              },
              n => {
                ((t, n) => {
                  c.get() ||
                    (e.selection.scrollIntoView(t.detail.element.dom),
                    t.suggestions.fold(
                      () => {
                        ((e, t) => {
                          t.block('Finding word suggestions'),
                            e.get(e => {
                              t.unblock(),
                                e.fold(
                                  () => {
                                    console.log('TinyMCE spellchecker fetch error');
                                  },
                                  e => {
                                    m(t, e);
                                  }
                                );
                            });
                        })(
                          Mo(e => {
                            a(t.detail).getOr(
                              o.getWordsSuggestionsAsync(
                                [t],
                                () => e(C.none()),
                                t => e(C.some(t)),
                                0
                              )
                            );
                          }).map(e => e.map(e => Zl(d, e, t.detail))),
                          n
                        );
                      },
                      e => {
                        const r = Zl(d, e, t.detail);
                        m(n, r);
                      }
                    ));
                })(n, t);
              }
            );
        },
        v = {
          open: () => {
            g.isSet() ||
              n.transact(
                Mo(t => {
                  n.clear(), c.set(!1), f.set(!0);
                  const r = Kl(d, [], '', []),
                    o = e.windowManager.open(r, s);
                  g.set(o), w(o, C.none(), 0), t();
                })
                  .bind(() => Mo(e => setTimeout(e)))
                  .bind(() =>
                    Mo(n => {
                      const r = {};
                      o.getWordsAsyncWithProgress((s, a) => {
                        f.set(!s),
                          u.set(() => {
                            s || a(), n();
                          });
                        const i = Co(e);
                        l.refreshCurrent(i), g.on(e => Jl(d, e));
                        const c = P(
                          i,
                          (e, n, o) => {
                            const { word: s, lang: l } = n;
                            return Q(r, l)
                              .fold(
                                () => {
                                  const e = [s];
                                  return (r[l] = e), C.some(n);
                                },
                                e => (I(e, e => s === e) ? C.none() : (e.push(s), C.some(n)))
                              )
                              .fold(b(e), () =>
                                t.suggestions(l, s).fold(
                                  () => (e.push({ detail: n, suggestions: C.none() }), e),
                                  () => e
                                )
                              );
                          },
                          []
                        );
                        c.length > 0 ? o.getWordsSuggestionsAsync(c, y, y, 0) : s && 0 === i.length && wo(e, {});
                        const p = Oo(e);
                        (s || p.isSome()) && (h.get()(), h.set(y));
                      }, !0);
                    })
                  )
              );
          },
          close: () =>
            g.on(e => {
              l.clear(), e.close();
            })
        };
      return v;
    };
  var Yl;
  tinymce.PluginManager.requireLangPack(
    'tinymcespellchecker',
    'ar,bg_BG,ca,cs,da,de,el,es,eu,fa,fi,fr_FR,he_IL,hi,hr,hu_HU,id,it,ja,kk,ko_KR,ms,nb_NO,nl,pl,pt_BR,pt_PT,ro,ru,sk,sl_SI,sv_SE,th_TH,tr,uk,vi,zh_CN,zh_TW'
  ),
    tinymce.PluginManager.add('tinymcespellchecker', (e, t) => {
      if (
        ((e, t) =>
          !!e &&
          -1 ===
            ((e, t) => {
              const n = Te(e.major, t.major);
              if (0 !== n) return n;
              const r = Te(e.minor, t.minor);
              if (0 !== r) return r;
              const o = Te(e.patch, t.patch);
              return 0 !== o ? o : 0;
            })(
              (e => Ee((e => [e.majorVersion, e.minorVersion].join('.').split('.').slice(0, 3).join('.'))(e)))(e),
              Ee(t)
            ))(tinymce, '6.0.0')
      )
        return console.error('The "tinymcespellchecker" plugin requires at least version 6.0.0 of TinyMCE.'), {};
      (e => {
        var t;
        const n = e.options.register;
        n('spellchecker_dialog', { processor: 'boolean', default: !1 }),
          n('spellchecker_language', {
            processor: 'string',
            default: null !== (t = e.getElement().getAttribute('lang')) && void 0 !== t ? t : 'en_us'
          }),
          n('spellchecker_languages', {
            processor: e =>
              s(e)
                ? { value: e.split(','), valid: !0 }
                : f(e, s)
                ? { value: e, valid: !0 }
                : { valid: !1, message: 'Must be a string or string array.' },
            default: ['en_us', 'en_gb', 'da', 'nl', 'fi', 'fr', 'de', 'it', 'nb', 'pt', 'pt_pt', 'es', 'sv']
          }),
          n('spellchecker_ignore_list', { processor: e => l(e) || f(e, s), default: [] }),
          n('spellchecker_handler', { processor: 'object' }),
          n('spellchecker_api_key', { processor: 'string' }),
          n('spellchecker_rpc_url', { processor: 'string', default: '' }),
          n('spellchecker_active', { processor: 'boolean', default: !0 }),
          n('spellchecker_service_chunk_size', { processor: 'number', default: As.chunkSize }),
          n('spellchecker_service_max_retries', { processor: 'number', default: As.maxRetries }),
          n('spellchecker_service_max_in_flight', { processor: 'number', default: As.maxInFlight });
      })(e);
      const n = Ls(e),
        r = Ps(e),
        o = ((e = {}) => {
          let t = {},
            n = {};
          const r = e => Q(t, e).getOr({}),
            o = (e, n) => {
              const o = r(e);
              n(o), (t[e] = o);
            },
            s = (e, t) => t(r(e)),
            l = (e, t, n) => {
              o(e, e => {
                const r = zs(t);
                Q(e, r).forall(e => e.suggestions.isNone()) && (e[r] = Ws(n, !1));
              });
            },
            a = (e, t) => {
              o(e, e => {
                const n = zs(t),
                  r = Q(e, n).bind(e => e.suggestions),
                  o = Ws(r, !0);
                e[n] = o;
              });
            };
          Z(e, (e, t) => {
            Z(e, (e, n) => {
              !0 === e.ignore && a(t, n), void 0 !== e.suggestions && l(t, n, C.some(e.suggestions));
            });
          });
          const i = e => Q(n, e).getOr([]);
          return {
            add: l,
            get: (e, t) =>
              s(e, e => {
                const n = zs(t);
                return Q(e, n);
              }),
            ignore: a,
            ignoreAll: e => {
              Z(t, (t, n) => {
                a(n, e);
              });
            },
            suggestions: (e, t) =>
              s(e, e => {
                const n = zs(t);
                return Q(e, n).bind(e => (e.ignore ? C.none() : e.suggestions));
              }),
            state: () => G(t, (e, t) => G(e, e => ({ ignore: e.ignore, suggestions: e.suggestions.getOr([]) }))),
            destroy: () => {
              (t = {}), (n = {});
            },
            getCorrect: i,
            addCorrect: (e, t) => {
              const r = i(e);
              n[e] = H(r.concat(t));
            }
          };
        })(c),
        a = Vl(n);
      var c;
      Bs(e) || 'no.language' === a.spelling().get() || a.spelling().set('no.language');
      const u = (e => {
          const t = !Is(e),
            n = e.options.get('spellchecker_languages'),
            r = X(
              ((e, t = !0) =>
                P(
                  e,
                  (e, n) => {
                    const [r, o] = Re(n, '=') ? n.split('=') : [null, n];
                    return (e[t ? hr(o) : o] = C.from(r).getOrThunk(() => fr(o))), e;
                  },
                  {}
                ))(n),
              (e, t) => ({ text: e, value: t })
            );
          return t ? Rs.concat(r) : r;
        })(e),
        g = !Is(e),
        d = (e => ({
          chunkSize: e.options.get('spellchecker_service_chunk_size'),
          maxRetries: e.options.get('spellchecker_service_max_retries'),
          maxInFlight: e.options.get('spellchecker_service_max_in_flight')
        }))(e),
        m = (e => {
          const t = new Set(),
            n = {};
          return (
            i(e)
              ? j(e, e => t.add(e))
              : Z(e, (e, t) => {
                  const r = hr(t);
                  n[r] = Fs(e);
                }),
            {
              isWordIgnored: (e, r) => !!t.has(r) || Q(n, e).fold(E, e => e.has(r)),
              addToLang: (e, t) => {
                Q(n, e).fold(
                  () => (n[e] = Fs([t])),
                  e => e.add(t)
                );
              },
              addToGlobal: e => {
                t.add(e);
              }
            }
          );
        })(js(e)),
        h = Fl(e, r, o, a, g, d, m),
        w = ((e, t, n, r, o) => {
          const s = t => {
              const r = vo(t);
              (r ? n.scanView : n.clear)(), (r ? ho : fo)(e);
            },
            l = n.checkDocument,
            a = (t, o, s, l) => {
              const i = () => {
                l < 3 ? a(t, o, s, l + 1) : o();
              };
              n.fetch(t).get(n => {
                n.length > 0
                  ? To(t[0].detail.element, r)
                      .bind(e => e.suggestions)
                      .fold(i, t => {
                        const r = {};
                        j(n, e => (r[e.language] = e.spelling)), wo(e, r), s(t);
                      })
                  : setTimeout(i, 1500 * (l + 1));
              });
            };
          return {
            changeLanguage: (n, r = !0) => {
              const l = hr(n),
                a = t.nonOffSpelling(),
                i = vo(t.spelling().get());
              r || i ? (t.spelling().setAndCache(e, l), o && s(l)) : t.setNonOffSpelling(l),
                vo(n) && n !== a && (fe(xe.fromDom(e.getBody()), 'lang', n), yo(e, n, a));
            },
            getLanguage: () => {
              const e = t.spelling().get();
              return vo(e) ? e : t.nonOffSpelling();
            },
            toggleLanguage: () => {
              const n = vo(t.spelling().get()) ? xo() : t.nonOffSpelling();
              t.spelling().setAndCache(e, n), s(n);
            },
            getWordsAsync: t => {
              l((n, r) => {
                n ? t() : e.removed && r();
              }, !1);
            },
            getWordsAsyncWithProgress: l,
            getWordsSuggestionsAsync: a,
            clean: () => {
              n.clear();
            },
            cleanUpAndRescan: () => {
              n.clear(), o && !e.removed && n.scanView();
            }
          };
        })(e, a, h, o, g),
        v = Gl(e, o, h, 0, w);
      return (
        ((e, t, n, r, o) => {
          const s =
            t =>
            (...n) => {
              e.mode.isReadOnly() || t(...n);
            };
          e.addCommand(
            'mceSpellcheckEnable',
            s(() => {
              o ? n.changeLanguage(r.nonOffSpelling()) : t.open();
            })
          ),
            e.addCommand('mceSpellcheckDisable', () => {
              o && n.changeLanguage(xo()), t.close();
            }),
            e.addCommand('mceSpellcheckDialog', s(t.open)),
            e.addCommand('mceSpellcheckDialogClose', t.close),
            e.addCommand(
              'mceSpellcheckUpdate',
              s(() =>
                n.getWordsAsync(() => {
                  const t = L(Co(e), e => ({ detail: e, suggestions: C.none() }));
                  t.length > 0 ? n.getWordsSuggestionsAsync(t, y, y, 0) : wo(e, {});
                })
              )
            );
        })(e, v, w, a, g),
        ((e, t) => {
          const n = (t, n) => ({
              text: n,
              onAction: () => {
                ko(e, t, n);
              }
            }),
            r = {
              getSubstituteItemsOverMax: (e, t, r) => {
                const o = t.slice(0, r),
                  s = t.slice(r),
                  l = L(o, t => n(e, t)),
                  a = L(s, t => n(e, t)),
                  i = { type: 'submenu', text: 'More...', getSubmenuItems: b(a) };
                return l.concat([i]);
              },
              getSubstituteItems: (e, t) => L(t, t => n(e, t)),
              getSeparator: () => ({ type: 'separator' }),
              getIgnoreItem: (t, n) => ({
                text: 'Ignore',
                onAction: () => {
                  So(e, t, n);
                }
              }),
              getIgnoreAllItem: (n, r, o) => ({
                text: 'Ignore all',
                onAction: () => {
                  Eo(e, n, r, o, t);
                }
              }),
              getNoSuggestionsMenuItem: () => ({ text: 'No suggestions', enabled: !1, onAction: y })
            };
          e.ui.registry.addContextMenu('spellchecker', {
            update: e => {
              const n = (e =>
                To(e, t).map(t =>
                  ((e, t, n, r, o) => {
                    const s = ((e, t, n) =>
                        0 === e.length
                          ? [t.getNoSuggestionsMenuItem()]
                          : e.length > 4
                          ? t.getSubstituteItemsOverMax(n, e, 4)
                          : t.getSubstituteItems(n, e))(r.getOr([]), o, e),
                      l = [o.getSeparator(), o.getIgnoreItem(e, n), o.getIgnoreAllItem(e, n, t)];
                    return s.concat(l);
                  })(e, t.detail.lang, t.detail.word, t.suggestions, r)
                ))(xe.fromDom(e));
              return n.getOr([]);
            }
          });
        })(e, o),
        ((e, t, n, r, o) => {
          const s = L(t, e => ({ ...e, type: 'choiceitem' })),
            l = {
              tooltip: 'Spellcheck...',
              icon: 'spell-check',
              onAction: () => {
                e.execCommand('mceSpellcheckDialog');
              }
            },
            a = {
              tooltip: 'Spellcheck...',
              icon: 'spell-check',
              onAction: () => {
                e.execCommand('mceSpellcheckDialog');
              },
              select: e => e === n.spelling().get(),
              fetch: e => {
                e(s);
              },
              onItemAction: (e, t) => {
                r.changeLanguage(t);
              }
            },
            i = {
              tooltip: 'Spellcheck',
              icon: 'spell-check',
              onAction: r.toggleLanguage,
              onSetup: t => {
                const r = () => {
                  t.setActive(vo(n.spelling().get()));
                };
                return r(), e.on(Ul, r), () => e.off(Ul, r);
              },
              select: e => e === n.spelling().get(),
              fetch: e => {
                e(s);
              },
              onItemAction: (e, t) => {
                r.changeLanguage(t);
              }
            },
            c = {
              text: 'Spellcheck...',
              icon: 'spell-check',
              onAction: () => {
                e.execCommand('mceSpellcheckDialog');
              }
            };
          o
            ? (e.ui.registry.addSplitButton('spellchecker', i),
              e.ui.registry.addToggleMenuItem('spellchecker', {
                text: 'Spellcheck',
                icon: 'spell-check',
                onAction: r.toggleLanguage,
                onSetup: t => {
                  const r = () => t.setActive(vo(n.spelling().get()));
                  return r(), e.on(Ul, r), () => e.off(Ul, r);
                }
              }),
              e.ui.registry.addButton('spellcheckdialog', l),
              e.ui.registry.addMenuItem('spellcheckdialog', c))
            : (e.ui.registry.addSplitButton('spellchecker', a), e.ui.registry.addMenuItem('spellchecker', c));
          const u = e => ({
            type: 'togglemenuitem',
            text: e.text,
            onAction: () => r.changeLanguage(e.value),
            active: e.value === n.spelling().get()
          });
          e.ui.registry.addNestedMenuItem('spellcheckerlanguage', {
            text: 'Spellcheck language',
            getSubmenuItems: () => L(s, u)
          });
        })(e, u, a, w, g),
        e.on('init', () => {
          vo(a.spelling().get()) && fe(xe.fromDom(e.getBody()), 'lang', a.spelling().get()),
            yo(e, a.spelling().get(), '');
        }),
        e.on('SwitchMode', e => {
          'design' === e.mode ? w.cleanUpAndRescan() : w.clean();
        }),
        e.on('EditableRootStateChange', () => {
          w.cleanUpAndRescan();
        }),
        ((e, t, n, r) => ({
          addIgnoredWords: (r, o) => {
            j(r, r => {
              if (p(o)) {
                const e = hr(o);
                t.addToLang(e, r), n.ignore(e, r);
              } else t.addToGlobal(r), n.ignoreAll(r);
              ((e, t, n) => {
                const r = Vr(e, t, n);
                j(r, e => at(e));
              })(xe.fromDom(e.getDoc()), r, o);
            });
          },
          getLanguage: r.getLanguage,
          setLanguage: e => r.changeLanguage(e, !1),
          getSpellingErrors: () => L(Co(e), ({ word: e, lang: t }) => ({ word: e, language: t }))
        }))(e, m, o, w)
      );
    });
})();
