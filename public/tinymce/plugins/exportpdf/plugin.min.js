/*!
 * Tiny Export to PDF plugin
 *
 * Copyright (c) 2024 Ephox Corporation DBA Tiny Technologies, Inc.
 * Licensed under the Tiny commercial license. See https://www.tiny.cloud/legal/
 *
 * Version: 7.5.1-62
 */

!(function () {
  'use strict';
  const t = t => parseInt(t, 10),
    e = (t, e) => {
      const n = t - e;
      return 0 === n ? 0 : n > 0 ? 1 : -1;
    },
    n = (t, e, n) => ({ major: t, minor: e, patch: n }),
    r = e => {
      const r = /([0-9]+)\.([0-9]+)\.([0-9]+)(?:(\-.+)?)/.exec(e);
      return r ? n(t(r[1]), t(r[2]), t(r[3])) : n(0, 0, 0);
    },
    o = Object.getPrototypeOf,
    i = (t, e, n) => {
      var r;
      return !!n(t, e.prototype) || (null === (r = t.constructor) || void 0 === r ? void 0 : r.name) === e.name;
    },
    s = t => e =>
      (t => {
        const e = typeof t;
        return null === t
          ? 'null'
          : 'object' === e && Array.isArray(t)
          ? 'array'
          : 'object' === e && i(t, String, (t, e) => e.isPrototypeOf(t))
          ? 'string'
          : e;
      })(e) === t,
    a = t => e => typeof e === t,
    l = t => e => t === e,
    c = s('string'),
    u = s('object'),
    h = t => ((t, e) => u(t) && i(t, e, (t, e) => o(t) === e))(t, Object),
    d = s('array'),
    p = l(null),
    f = a('boolean'),
    m = l(void 0),
    g = t => !(t => null == t)(t),
    k = a('function'),
    y = a('number'),
    v = () => {},
    b = t => () => t,
    S = t => t;
  function C(t, ...e) {
    return (...n) => {
      const r = e.concat(n);
      return t.apply(null, r);
    };
  }
  const w = t => t(),
    x = b(!1),
    A = b(!0);
  class _ {
    constructor(t, e) {
      (this.tag = t), (this.value = e);
    }
    static some(t) {
      return new _(!0, t);
    }
    static none() {
      return _.singletonNone;
    }
    fold(t, e) {
      return this.tag ? e(this.value) : t();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(t) {
      return this.tag ? _.some(t(this.value)) : _.none();
    }
    bind(t) {
      return this.tag ? t(this.value) : _.none();
    }
    exists(t) {
      return this.tag && t(this.value);
    }
    forall(t) {
      return !this.tag || t(this.value);
    }
    filter(t) {
      return !this.tag || t(this.value) ? this : _.none();
    }
    getOr(t) {
      return this.tag ? this.value : t;
    }
    or(t) {
      return this.tag ? this : t;
    }
    getOrThunk(t) {
      return this.tag ? this.value : t();
    }
    orThunk(t) {
      return this.tag ? this : t();
    }
    getOrDie(t) {
      if (this.tag) return this.value;
      throw new Error(null != t ? t : 'Called getOrDie on None');
    }
    static from(t) {
      return g(t) ? _.some(t) : _.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(t) {
      this.tag && t(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : 'none()';
    }
  }
  _.singletonNone = new _(!1);
  const L = Array.prototype.slice,
    E = Array.prototype.indexOf,
    T = Array.prototype.push,
    O = (t, e) => ((t, e) => E.call(t, e))(t, e) > -1,
    P = (t, e) => {
      const n = t.length,
        r = new Array(n);
      for (let o = 0; o < n; o++) {
        const n = t[o];
        r[o] = e(n, o);
      }
      return r;
    },
    I = (t, e) => {
      for (let n = 0, r = t.length; n < r; n++) e(t[n], n);
    },
    N = (t, e) => {
      const n = [];
      for (let r = 0, o = t.length; r < o; r++) {
        const o = t[r];
        e(o, r) && n.push(o);
      }
      return n;
    },
    j = (t, e) =>
      (t => {
        const e = [];
        for (let n = 0, r = t.length; n < r; ++n) {
          if (!d(t[n])) throw new Error('Arr.flatten item ' + n + ' was not an array, input: ' + t);
          T.apply(e, t[n]);
        }
        return e;
      })(P(t, e)),
    M = k(Array.from) ? Array.from : t => L.call(t),
    D = t => {
      if (null == t) throw new Error('Node cannot be null or undefined');
      return { dom: t };
    },
    R = (t, e) => {
      const n = (e || document).createElement(t);
      return D(n);
    },
    B = D,
    U = (t, e) => {
      const n = t.dom;
      if (1 !== n.nodeType) return !1;
      {
        const t = n;
        if (void 0 !== t.matches) return t.matches(e);
        if (void 0 !== t.msMatchesSelector) return t.msMatchesSelector(e);
        if (void 0 !== t.webkitMatchesSelector) return t.webkitMatchesSelector(e);
        if (void 0 !== t.mozMatchesSelector) return t.mozMatchesSelector(e);
        throw new Error('Browser lacks native selectors');
      }
    },
    $ = 'undefined' != typeof window ? window : Function('return this;')(),
    F = (t, e) =>
      ((t, e) => {
        let n = null != e ? e : $;
        for (let e = 0; e < t.length && null != n; ++e) n = n[t[e]];
        return n;
      })(t.split('.'), e),
    V = Object.getPrototypeOf,
    z = t => {
      const e = F('ownerDocument.defaultView', t);
      return (
        u(t) &&
        ((t =>
          ((t, e) => {
            const n = ((t, e) => F(t, e))(t, e);
            if (null == n) throw new Error(t + ' not available on this browser');
            return n;
          })('HTMLElement', t))(e).prototype.isPrototypeOf(t) ||
          /^HTML\w*Element$/.test(V(t).constructor.name))
      );
    },
    q = t => e => (t => t.dom.nodeType)(e) === t,
    W = q(1),
    G = q(9),
    H = q(11),
    J = t => B(t.dom.ownerDocument),
    K = t => (G(t) ? t : J(t)),
    Q = t => P(t.dom.childNodes, B),
    Y = (t, e) => {
      t.dom.appendChild(e.dom);
    },
    X = t => {
      const e = t.dom;
      null !== e.parentNode && e.parentNode.removeChild(e);
    },
    Z = (t, e) => {
      const n = J(t).dom,
        r = B(n.createDocumentFragment()),
        o = ((t, e) => {
          const n = (e || document).createElement('div');
          return (n.innerHTML = t), Q(B(n));
        })(e, n);
      var i;
      (i = r),
        I(o, t => {
          Y(i, t);
        }),
        (t => {
          (t.dom.textContent = ''),
            I(Q(t), t => {
              X(t);
            });
        })(t),
        Y(t, r);
    },
    tt = t => B(t.dom.getRootNode()),
    et = t => {
      const e = t.dom.body;
      if (null == e) throw new Error('Body is not available yet');
      return B(e);
    },
    nt = (t, e) =>
      ((t, n) => {
        return ((r = t.dom.childNodes),
        (o = t => (t => U(t, e))(B(t))),
        ((t, e, n) => {
          for (let r = 0, o = t.length; r < o; r++) {
            const o = t[r];
            if (e(o, r)) return _.some(o);
            if (n(o, r)) break;
          }
          return _.none();
        })(r, o, x)).map(B);
        var r, o;
      })(t),
    rt = Object.keys,
    ot = Object.hasOwnProperty,
    it = (t, e) => {
      const n = rt(t);
      for (let r = 0, o = n.length; r < o; r++) {
        const o = n[r];
        e(t[o], o);
      }
    },
    st = (t, e) => (at(t, e) ? _.from(t[e]) : _.none()),
    at = (t, e) => ot.call(t, e),
    lt = (t, e, n) => {
      ((t, e, n) => {
        if (!(c(n) || f(n) || y(n)))
          throw (
            (console.error('Invalid call to Attribute.set. Key ', e, ':: Value ', n, ':: Element ', t),
            new Error('Attribute value was not simple'))
          );
        t.setAttribute(e, n + '');
      })(t.dom, e, n);
    },
    ct = t => void 0 !== t.style && k(t.style.getPropertyValue),
    ut = (t, e, n) => {
      if (!c(n))
        throw (
          (console.error('Invalid call to CSS.set. Property ', e, ':: Value ', n, ':: Element ', t),
          new Error('CSS value must be a string: ' + n))
        );
      ct(t) && t.style.setProperty(e, n);
    },
    ht = (t, e) => {
      const n = t.dom;
      it(e, (t, e) => {
        ut(n, e, t);
      });
    };
  var dt = Object.create,
    pt = Object.defineProperty,
    ft = Object.getOwnPropertyDescriptor,
    mt = Object.getOwnPropertyNames,
    gt = Object.getPrototypeOf,
    kt = Object.prototype.hasOwnProperty,
    yt = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports),
    vt = (t, e) => {
      for (var n in e) pt(t, n, { get: e[n], enumerable: !0 });
    },
    bt = yt(t => {
      var e = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
      (t.encode = function (t) {
        if (0 <= t && t < e.length) return e[t];
        throw new TypeError('Must be between 0 and 63: ' + t);
      }),
        (t.decode = function (t) {
          return 65 <= t && t <= 90
            ? t - 65
            : 97 <= t && t <= 122
            ? t - 97 + 26
            : 48 <= t && t <= 57
            ? t - 48 + 52
            : 43 == t
            ? 62
            : 47 == t
            ? 63
            : -1;
        });
    }),
    St = yt(t => {
      var e = bt();
      (t.encode = function (t) {
        var n,
          r,
          o = '',
          i = (r = t) < 0 ? 1 + (-r << 1) : 0 + (r << 1);
        do {
          (n = 31 & i), (i >>>= 5) > 0 && (n |= 32), (o += e.encode(n));
        } while (i > 0);
        return o;
      }),
        (t.decode = function (t, n, r) {
          var o,
            i,
            s = t.length,
            a = 0,
            l = 0;
          do {
            if (n >= s) throw new Error('Expected more digits in base 64 VLQ value.');
            if (-1 === (i = e.decode(t.charCodeAt(n++)))) throw new Error('Invalid base64 digit: ' + t.charAt(n - 1));
            (o = !!(32 & i)), (a += (i &= 31) << l), (l += 5);
          } while (o);
          (r.value = (function (t) {
            var e = t >> 1;
            return 1 == (1 & t) ? -e : e;
          })(a)),
            (r.rest = n);
        });
    }),
    Ct = yt(t => {
      t.getArg = function (t, e, n) {
        if (e in t) return t[e];
        if (3 === arguments.length) return n;
        throw new Error('"' + e + '" is a required argument.');
      };
      var e = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/,
        n = /^data:.+\,.+$/;
      function r(t) {
        var n = t.match(e);
        return n ? { scheme: n[1], auth: n[2], host: n[3], port: n[4], path: n[5] } : null;
      }
      function o(t) {
        var e = '';
        return (
          t.scheme && (e += t.scheme + ':'),
          (e += '//'),
          t.auth && (e += t.auth + '@'),
          t.host && (e += t.host),
          t.port && (e += ':' + t.port),
          t.path && (e += t.path),
          e
        );
      }
      (t.urlParse = r), (t.urlGenerate = o);
      var i,
        s,
        a =
          ((i = function (e) {
            var n = e,
              i = r(e);
            if (i) {
              if (!i.path) return e;
              n = i.path;
            }
            for (var s = t.isAbsolute(n), a = [], l = 0, c = 0; ; ) {
              if (((l = c), -1 === (c = n.indexOf('/', l)))) {
                a.push(n.slice(l));
                break;
              }
              for (a.push(n.slice(l, c)); c < n.length && '/' === n[c]; ) c++;
            }
            var u,
              h = 0;
            for (c = a.length - 1; c >= 0; c--)
              '.' === (u = a[c])
                ? a.splice(c, 1)
                : '..' === u
                ? h++
                : h > 0 && ('' === u ? (a.splice(c + 1, h), (h = 0)) : (a.splice(c, 2), h--));
            return '' === (n = a.join('/')) && (n = s ? '/' : '.'), i ? ((i.path = n), o(i)) : n;
          }),
          (s = []),
          function (t) {
            for (var e = 0; e < s.length; e++)
              if (s[e].input === t) {
                var n = s[0];
                return (s[0] = s[e]), (s[e] = n), s[0].result;
              }
            var r = i(t);
            return s.unshift({ input: t, result: r }), s.length > 32 && s.pop(), r;
          });
      function l(t, e) {
        '' === t && (t = '.'), '' === e && (e = '.');
        var i = r(e),
          s = r(t);
        if ((s && (t = s.path || '/'), i && !i.scheme)) return s && (i.scheme = s.scheme), o(i);
        if (i || e.match(n)) return e;
        if (s && !s.host && !s.path) return (s.host = e), o(s);
        var l = '/' === e.charAt(0) ? e : a(t.replace(/\/+$/, '') + '/' + e);
        return s ? ((s.path = l), o(s)) : l;
      }
      (t.normalize = a),
        (t.join = l),
        (t.isAbsolute = function (t) {
          return '/' === t.charAt(0) || e.test(t);
        }),
        (t.relative = function (t, e) {
          '' === t && (t = '.'), (t = t.replace(/\/$/, ''));
          for (var n = 0; 0 !== e.indexOf(t + '/'); ) {
            var r = t.lastIndexOf('/');
            if (r < 0 || (t = t.slice(0, r)).match(/^([^\/]+:\/)?\/*$/)) return e;
            ++n;
          }
          return Array(n + 1).join('../') + e.substr(t.length + 1);
        });
      var c = !('__proto__' in Object.create(null));
      function u(t) {
        return t;
      }
      function h(t) {
        if (!t) return !1;
        var e = t.length;
        if (
          e < 9 ||
          95 !== t.charCodeAt(e - 1) ||
          95 !== t.charCodeAt(e - 2) ||
          111 !== t.charCodeAt(e - 3) ||
          116 !== t.charCodeAt(e - 4) ||
          111 !== t.charCodeAt(e - 5) ||
          114 !== t.charCodeAt(e - 6) ||
          112 !== t.charCodeAt(e - 7) ||
          95 !== t.charCodeAt(e - 8) ||
          95 !== t.charCodeAt(e - 9)
        )
          return !1;
        for (var n = e - 10; n >= 0; n--) if (36 !== t.charCodeAt(n)) return !1;
        return !0;
      }
      function d(t, e) {
        return t === e ? 0 : null === t ? 1 : null === e ? -1 : t > e ? 1 : -1;
      }
      (t.toSetString = c
        ? u
        : function (t) {
            return h(t) ? '$' + t : t;
          }),
        (t.fromSetString = c
          ? u
          : function (t) {
              return h(t) ? t.slice(1) : t;
            }),
        (t.compareByOriginalPositions = function (t, e, n) {
          var r = d(t.source, e.source);
          return 0 !== r ||
            0 != (r = t.originalLine - e.originalLine) ||
            0 != (r = t.originalColumn - e.originalColumn) ||
            n ||
            0 != (r = t.generatedColumn - e.generatedColumn) ||
            0 != (r = t.generatedLine - e.generatedLine)
            ? r
            : d(t.name, e.name);
        }),
        (t.compareByOriginalPositionsNoSource = function (t, e, n) {
          var r;
          return 0 != (r = t.originalLine - e.originalLine) ||
            0 != (r = t.originalColumn - e.originalColumn) ||
            n ||
            0 != (r = t.generatedColumn - e.generatedColumn) ||
            0 != (r = t.generatedLine - e.generatedLine)
            ? r
            : d(t.name, e.name);
        }),
        (t.compareByGeneratedPositionsDeflated = function (t, e, n) {
          var r = t.generatedLine - e.generatedLine;
          return 0 !== r ||
            0 != (r = t.generatedColumn - e.generatedColumn) ||
            n ||
            0 !== (r = d(t.source, e.source)) ||
            0 != (r = t.originalLine - e.originalLine) ||
            0 != (r = t.originalColumn - e.originalColumn)
            ? r
            : d(t.name, e.name);
        }),
        (t.compareByGeneratedPositionsDeflatedNoLine = function (t, e, n) {
          var r = t.generatedColumn - e.generatedColumn;
          return 0 !== r ||
            n ||
            0 !== (r = d(t.source, e.source)) ||
            0 != (r = t.originalLine - e.originalLine) ||
            0 != (r = t.originalColumn - e.originalColumn)
            ? r
            : d(t.name, e.name);
        }),
        (t.compareByGeneratedPositionsInflated = function (t, e) {
          var n = t.generatedLine - e.generatedLine;
          return 0 !== n ||
            0 != (n = t.generatedColumn - e.generatedColumn) ||
            0 !== (n = d(t.source, e.source)) ||
            0 != (n = t.originalLine - e.originalLine) ||
            0 != (n = t.originalColumn - e.originalColumn)
            ? n
            : d(t.name, e.name);
        }),
        (t.parseSourceMapInput = function (t) {
          return JSON.parse(t.replace(/^\)]}'[^\n]*\n/, ''));
        }),
        (t.computeSourceURL = function (t, e, n) {
          if (((e = e || ''), t && ('/' !== t[t.length - 1] && '/' !== e[0] && (t += '/'), (e = t + e)), n)) {
            var i = r(n);
            if (!i) throw new Error('sourceMapURL could not be parsed');
            if (i.path) {
              var s = i.path.lastIndexOf('/');
              s >= 0 && (i.path = i.path.substring(0, s + 1));
            }
            e = l(o(i), e);
          }
          return a(e);
        });
    }),
    wt = yt(t => {
      var e = Ct(),
        n = Object.prototype.hasOwnProperty,
        r = typeof Map < 'u';
      function o() {
        (this._array = []), (this._set = r ? new Map() : Object.create(null));
      }
      (o.fromArray = function (t, e) {
        for (var n = new o(), r = 0, i = t.length; r < i; r++) n.add(t[r], e);
        return n;
      }),
        (o.prototype.size = function () {
          return r ? this._set.size : Object.getOwnPropertyNames(this._set).length;
        }),
        (o.prototype.add = function (t, o) {
          var i = r ? t : e.toSetString(t),
            s = r ? this.has(t) : n.call(this._set, i),
            a = this._array.length;
          (!s || o) && this._array.push(t), s || (r ? this._set.set(t, a) : (this._set[i] = a));
        }),
        (o.prototype.has = function (t) {
          if (r) return this._set.has(t);
          var o = e.toSetString(t);
          return n.call(this._set, o);
        }),
        (o.prototype.indexOf = function (t) {
          if (r) {
            var o = this._set.get(t);
            if (o >= 0) return o;
          } else {
            var i = e.toSetString(t);
            if (n.call(this._set, i)) return this._set[i];
          }
          throw new Error('"' + t + '" is not in the set.');
        }),
        (o.prototype.at = function (t) {
          if (t >= 0 && t < this._array.length) return this._array[t];
          throw new Error('No element indexed by ' + t);
        }),
        (o.prototype.toArray = function () {
          return this._array.slice();
        }),
        (t.ArraySet = o);
    }),
    xt = yt(t => {
      var e = Ct();
      function n() {
        (this._array = []), (this._sorted = !0), (this._last = { generatedLine: -1, generatedColumn: 0 });
      }
      (n.prototype.unsortedForEach = function (t, e) {
        this._array.forEach(t, e);
      }),
        (n.prototype.add = function (t) {
          !(function (t, n) {
            var r = t.generatedLine,
              o = n.generatedLine,
              i = t.generatedColumn,
              s = n.generatedColumn;
            return o > r || (o == r && s >= i) || e.compareByGeneratedPositionsInflated(t, n) <= 0;
          })(this._last, t)
            ? ((this._sorted = !1), this._array.push(t))
            : ((this._last = t), this._array.push(t));
        }),
        (n.prototype.toArray = function () {
          return (
            this._sorted || (this._array.sort(e.compareByGeneratedPositionsInflated), (this._sorted = !0)), this._array
          );
        }),
        (t.MappingList = n);
    }),
    At = yt(t => {
      var e = St(),
        n = Ct(),
        r = wt().ArraySet,
        o = xt().MappingList;
      function i(t) {
        t || (t = {}),
          (this._file = n.getArg(t, 'file', null)),
          (this._sourceRoot = n.getArg(t, 'sourceRoot', null)),
          (this._skipValidation = n.getArg(t, 'skipValidation', !1)),
          (this._sources = new r()),
          (this._names = new r()),
          (this._mappings = new o()),
          (this._sourcesContents = null);
      }
      (i.prototype._version = 3),
        (i.fromSourceMap = function (t) {
          var e = t.sourceRoot,
            r = new i({ file: t.file, sourceRoot: e });
          return (
            t.eachMapping(function (t) {
              var o = { generated: { line: t.generatedLine, column: t.generatedColumn } };
              null != t.source &&
                ((o.source = t.source),
                null != e && (o.source = n.relative(e, o.source)),
                (o.original = { line: t.originalLine, column: t.originalColumn }),
                null != t.name && (o.name = t.name)),
                r.addMapping(o);
            }),
            t.sources.forEach(function (o) {
              var i = o;
              null !== e && (i = n.relative(e, o)), r._sources.has(i) || r._sources.add(i);
              var s = t.sourceContentFor(o);
              null != s && r.setSourceContent(o, s);
            }),
            r
          );
        }),
        (i.prototype.addMapping = function (t) {
          var e = n.getArg(t, 'generated'),
            r = n.getArg(t, 'original', null),
            o = n.getArg(t, 'source', null),
            i = n.getArg(t, 'name', null);
          this._skipValidation || this._validateMapping(e, r, o, i),
            null != o && ((o = String(o)), this._sources.has(o) || this._sources.add(o)),
            null != i && ((i = String(i)), this._names.has(i) || this._names.add(i)),
            this._mappings.add({
              generatedLine: e.line,
              generatedColumn: e.column,
              originalLine: null != r && r.line,
              originalColumn: null != r && r.column,
              source: o,
              name: i
            });
        }),
        (i.prototype.setSourceContent = function (t, e) {
          var r = t;
          null != this._sourceRoot && (r = n.relative(this._sourceRoot, r)),
            null != e
              ? (this._sourcesContents || (this._sourcesContents = Object.create(null)),
                (this._sourcesContents[n.toSetString(r)] = e))
              : this._sourcesContents &&
                (delete this._sourcesContents[n.toSetString(r)],
                0 === Object.keys(this._sourcesContents).length && (this._sourcesContents = null));
        }),
        (i.prototype.applySourceMap = function (t, e, o) {
          var i = e;
          if (null == e) {
            if (null == t.file)
              throw new Error(
                'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.'
              );
            i = t.file;
          }
          var s = this._sourceRoot;
          null != s && (i = n.relative(s, i));
          var a = new r(),
            l = new r();
          this._mappings.unsortedForEach(function (e) {
            if (e.source === i && null != e.originalLine) {
              var r = t.originalPositionFor({ line: e.originalLine, column: e.originalColumn });
              null != r.source &&
                ((e.source = r.source),
                null != o && (e.source = n.join(o, e.source)),
                null != s && (e.source = n.relative(s, e.source)),
                (e.originalLine = r.line),
                (e.originalColumn = r.column),
                null != r.name && (e.name = r.name));
            }
            var c = e.source;
            null != c && !a.has(c) && a.add(c);
            var u = e.name;
            null != u && !l.has(u) && l.add(u);
          }, this),
            (this._sources = a),
            (this._names = l),
            t.sources.forEach(function (e) {
              var r = t.sourceContentFor(e);
              null != r &&
                (null != o && (e = n.join(o, e)), null != s && (e = n.relative(s, e)), this.setSourceContent(e, r));
            }, this);
        }),
        (i.prototype._validateMapping = function (t, e, n, r) {
          if (e && 'number' != typeof e.line && 'number' != typeof e.column)
            throw new Error(
              'original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.'
            );
          if (!(t && 'line' in t && 'column' in t && t.line > 0 && t.column >= 0) || e || n || r) {
            if (
              t &&
              'line' in t &&
              'column' in t &&
              e &&
              'line' in e &&
              'column' in e &&
              t.line > 0 &&
              t.column >= 0 &&
              e.line > 0 &&
              e.column >= 0 &&
              n
            )
              return;
            throw new Error('Invalid mapping: ' + JSON.stringify({ generated: t, source: n, original: e, name: r }));
          }
        }),
        (i.prototype._serializeMappings = function () {
          for (
            var t,
              r,
              o,
              i,
              s = 0,
              a = 1,
              l = 0,
              c = 0,
              u = 0,
              h = 0,
              d = '',
              p = this._mappings.toArray(),
              f = 0,
              m = p.length;
            f < m;
            f++
          ) {
            if (((t = ''), (r = p[f]).generatedLine !== a)) for (s = 0; r.generatedLine !== a; ) (t += ';'), a++;
            else if (f > 0) {
              if (!n.compareByGeneratedPositionsInflated(r, p[f - 1])) continue;
              t += ',';
            }
            (t += e.encode(r.generatedColumn - s)),
              (s = r.generatedColumn),
              null != r.source &&
                ((i = this._sources.indexOf(r.source)),
                (t += e.encode(i - h)),
                (h = i),
                (t += e.encode(r.originalLine - 1 - c)),
                (c = r.originalLine - 1),
                (t += e.encode(r.originalColumn - l)),
                (l = r.originalColumn),
                null != r.name && ((o = this._names.indexOf(r.name)), (t += e.encode(o - u)), (u = o))),
              (d += t);
          }
          return d;
        }),
        (i.prototype._generateSourcesContent = function (t, e) {
          return t.map(function (t) {
            if (!this._sourcesContents) return null;
            null != e && (t = n.relative(e, t));
            var r = n.toSetString(t);
            return Object.prototype.hasOwnProperty.call(this._sourcesContents, r) ? this._sourcesContents[r] : null;
          }, this);
        }),
        (i.prototype.toJSON = function () {
          var t = {
            version: this._version,
            sources: this._sources.toArray(),
            names: this._names.toArray(),
            mappings: this._serializeMappings()
          };
          return (
            null != this._file && (t.file = this._file),
            null != this._sourceRoot && (t.sourceRoot = this._sourceRoot),
            this._sourcesContents && (t.sourcesContent = this._generateSourcesContent(t.sources, t.sourceRoot)),
            t
          );
        }),
        (i.prototype.toString = function () {
          return JSON.stringify(this.toJSON());
        }),
        (t.SourceMapGenerator = i);
    });
  function _t(t) {
    return t >= 48 && t <= 57;
  }
  function Lt(t) {
    return _t(t) || (t >= 65 && t <= 70) || (t >= 97 && t <= 102);
  }
  function Et(t) {
    return t >= 65 && t <= 90;
  }
  function Tt(t) {
    return (
      (function (t) {
        return (
          Et(t) ||
          (function (t) {
            return t >= 97 && t <= 122;
          })(t)
        );
      })(t) ||
      (function (t) {
        return t >= 128;
      })(t) ||
      95 === t
    );
  }
  function Ot(t) {
    return Tt(t) || _t(t) || 45 === t;
  }
  function Pt(t) {
    return (t >= 0 && t <= 8) || 11 === t || (t >= 14 && t <= 31) || 127 === t;
  }
  function It(t) {
    return 10 === t || 13 === t || 12 === t;
  }
  function Nt(t) {
    return It(t) || 32 === t || 9 === t;
  }
  function jt(t, e) {
    return !(92 !== t || It(e) || 0 === e);
  }
  function Mt(t, e, n) {
    return 45 === t ? Tt(e) || 45 === e || jt(e, n) : !!Tt(t) || (92 === t && jt(t, e));
  }
  function Dt(t, e, n) {
    return 43 === t || 45 === t ? (_t(e) ? 2 : 46 === e && _t(n) ? 3 : 0) : 46 === t ? (_t(e) ? 2 : 0) : _t(t) ? 1 : 0;
  }
  function Rt(t) {
    return 65279 === t || 65534 === t ? 1 : 0;
  }
  var Bt = new Array(128),
    Ut = 130,
    $t = 131,
    Ft = 132,
    Vt = 133;
  for (let t = 0; t < Bt.length; t++)
    Bt[t] = (Nt(t) && Ut) || (_t(t) && $t) || (Tt(t) && Ft) || (Pt(t) && Vt) || t || 128;
  function zt(t) {
    return t < 128 ? Bt[t] : Ft;
  }
  function qt(t, e) {
    return e < t.length ? t.charCodeAt(e) : 0;
  }
  function Wt(t, e, n) {
    return 13 === n && 10 === qt(t, e + 1) ? 2 : 1;
  }
  function Gt(t, e, n) {
    let r = t.charCodeAt(e);
    return Et(r) && (r |= 32), r === n;
  }
  function Ht(t, e, n, r) {
    if (n - e !== r.length || e < 0 || n > t.length) return !1;
    for (let o = e; o < n; o++) {
      let n = r.charCodeAt(o - e),
        i = t.charCodeAt(o);
      if ((Et(i) && (i |= 32), i !== n)) return !1;
    }
    return !0;
  }
  function Jt(t, e) {
    for (; e < t.length && Nt(t.charCodeAt(e)); e++);
    return e;
  }
  function Kt(t, e) {
    for (; e < t.length && _t(t.charCodeAt(e)); e++);
    return e;
  }
  function Qt(t, e) {
    if (Lt(qt(t, (e += 2) - 1))) {
      for (let n = Math.min(t.length, e + 5); e < n && Lt(qt(t, e)); e++);
      let n = qt(t, e);
      Nt(n) && (e += Wt(t, e, n));
    }
    return e;
  }
  function Yt(t, e) {
    for (; e < t.length; e++) {
      let n = t.charCodeAt(e);
      if (!Ot(n)) {
        if (jt(n, qt(t, e + 1))) {
          e = Qt(t, e) - 1;
          continue;
        }
        break;
      }
    }
    return e;
  }
  function Xt(t, e) {
    let n = t.charCodeAt(e);
    if (
      ((43 === n || 45 === n) && (n = t.charCodeAt((e += 1))),
      _t(n) && ((e = Kt(t, e + 1)), (n = t.charCodeAt(e))),
      46 === n && _t(t.charCodeAt(e + 1)) && (e = Kt(t, (e += 2))),
      Gt(t, e, 101))
    ) {
      let r = 0;
      (n = t.charCodeAt(e + 1)),
        (45 === n || 43 === n) && ((r = 1), (n = t.charCodeAt(e + 2))),
        _t(n) && (e = Kt(t, e + 1 + r + 1));
    }
    return e;
  }
  function Zt(t, e) {
    for (; e < t.length; e++) {
      let n = t.charCodeAt(e);
      if (41 === n) {
        e++;
        break;
      }
      jt(n, qt(t, e + 1)) && (e = Qt(t, e));
    }
    return e;
  }
  function te(t) {
    if (1 === t.length && !Lt(t.charCodeAt(0))) return t[0];
    let e = parseInt(t, 16);
    return (0 === e || (e >= 55296 && e <= 57343) || e > 1114111) && (e = 65533), String.fromCodePoint(e);
  }
  var ee = [
    'EOF-token',
    'ident-token',
    'function-token',
    'at-keyword-token',
    'hash-token',
    'string-token',
    'bad-string-token',
    'url-token',
    'bad-url-token',
    'delim-token',
    'number-token',
    'percentage-token',
    'dimension-token',
    'whitespace-token',
    'CDO-token',
    'CDC-token',
    'colon-token',
    'semicolon-token',
    'comma-token',
    '[-token',
    ']-token',
    '(-token',
    ')-token',
    '{-token',
    '}-token'
  ];
  function ne(t = null, e) {
    return null === t || t.length < e ? new Uint32Array(Math.max(e + 1024, 16384)) : t;
  }
  function re(t) {
    let e = t.source,
      n = e.length,
      r = e.length > 0 ? Rt(e.charCodeAt(0)) : 0,
      o = ne(t.lines, n),
      i = ne(t.columns, n),
      s = t.startLine,
      a = t.startColumn;
    for (let t = r; t < n; t++) {
      let r = e.charCodeAt(t);
      (o[t] = s),
        (i[t] = a++),
        (10 === r || 13 === r || 12 === r) &&
          (13 === r && t + 1 < n && 10 === e.charCodeAt(t + 1) && (t++, (o[t] = s), (i[t] = a)), s++, (a = 1));
    }
    (o[n] = s), (i[n] = a), (t.lines = o), (t.columns = i), (t.computed = !0);
  }
  var oe = class {
      constructor() {
        (this.lines = null), (this.columns = null), (this.computed = !1);
      }
      setSource(t, e = 0, n = 1, r = 1) {
        (this.source = t), (this.startOffset = e), (this.startLine = n), (this.startColumn = r), (this.computed = !1);
      }
      getLocation(t, e) {
        return (
          this.computed || re(this),
          { source: e, offset: this.startOffset + t, line: this.lines[t], column: this.columns[t] }
        );
      }
      getLocationRange(t, e, n) {
        return (
          this.computed || re(this),
          {
            source: n,
            start: { offset: this.startOffset + t, line: this.lines[t], column: this.columns[t] },
            end: { offset: this.startOffset + e, line: this.lines[e], column: this.columns[e] }
          }
        );
      }
    },
    ie = 16777215,
    se = 24,
    ae = new Map([
      [2, 22],
      [21, 22],
      [19, 20],
      [23, 24]
    ]),
    le = class {
      constructor(t, e) {
        this.setSource(t, e);
      }
      reset() {
        (this.eof = !1),
          (this.tokenIndex = -1),
          (this.tokenType = 0),
          (this.tokenStart = this.firstCharOffset),
          (this.tokenEnd = this.firstCharOffset);
      }
      setSource(t = '', e = () => {}) {
        let n = (t = String(t || '')).length,
          r = ne(this.offsetAndType, t.length + 1),
          o = ne(this.balance, t.length + 1),
          i = 0,
          s = 0,
          a = 0,
          l = -1;
        for (
          this.offsetAndType = null,
            this.balance = null,
            e(t, (t, e, c) => {
              switch (t) {
                default:
                  o[i] = n;
                  break;
                case s: {
                  let t = a & ie;
                  for (a = o[t], s = a >> se, o[i] = t, o[t++] = i; t < i; t++) o[t] === n && (o[t] = i);
                  break;
                }
                case 21:
                case 2:
                case 19:
                case 23:
                  (o[i] = a), (s = ae.get(t)), (a = (s << se) | i);
              }
              (r[i++] = (t << se) | c), -1 === l && (l = e);
            }),
            r[i] = 0 | n,
            o[i] = n,
            o[n] = n;
          0 !== a;

        ) {
          let t = a & ie;
          (a = o[t]), (o[t] = n);
        }
        (this.source = t),
          (this.firstCharOffset = -1 === l ? 0 : l),
          (this.tokenCount = i),
          (this.offsetAndType = r),
          (this.balance = o),
          this.reset(),
          this.next();
      }
      lookupType(t) {
        return (t += this.tokenIndex) < this.tokenCount ? this.offsetAndType[t] >> se : 0;
      }
      lookupOffset(t) {
        return (t += this.tokenIndex) < this.tokenCount ? this.offsetAndType[t - 1] & ie : this.source.length;
      }
      lookupValue(t, e) {
        return (
          (t += this.tokenIndex) < this.tokenCount &&
          Ht(this.source, this.offsetAndType[t - 1] & ie, this.offsetAndType[t] & ie, e)
        );
      }
      getTokenStart(t) {
        return t === this.tokenIndex
          ? this.tokenStart
          : t > 0
          ? t < this.tokenCount
            ? this.offsetAndType[t - 1] & ie
            : this.offsetAndType[this.tokenCount] & ie
          : this.firstCharOffset;
      }
      substrToCursor(t) {
        return this.source.substring(t, this.tokenStart);
      }
      isBalanceEdge(t) {
        return this.balance[this.tokenIndex] < t;
      }
      isDelim(t, e) {
        return e
          ? 9 === this.lookupType(e) && this.source.charCodeAt(this.lookupOffset(e)) === t
          : 9 === this.tokenType && this.source.charCodeAt(this.tokenStart) === t;
      }
      skip(t) {
        let e = this.tokenIndex + t;
        e < this.tokenCount
          ? ((this.tokenIndex = e),
            (this.tokenStart = this.offsetAndType[e - 1] & ie),
            (e = this.offsetAndType[e]),
            (this.tokenType = e >> se),
            (this.tokenEnd = e & ie))
          : ((this.tokenIndex = this.tokenCount), this.next());
      }
      next() {
        let t = this.tokenIndex + 1;
        t < this.tokenCount
          ? ((this.tokenIndex = t),
            (this.tokenStart = this.tokenEnd),
            (t = this.offsetAndType[t]),
            (this.tokenType = t >> se),
            (this.tokenEnd = t & ie))
          : ((this.eof = !0),
            (this.tokenIndex = this.tokenCount),
            (this.tokenType = 0),
            (this.tokenStart = this.tokenEnd = this.source.length));
      }
      skipSC() {
        for (; 13 === this.tokenType || 25 === this.tokenType; ) this.next();
      }
      skipUntilBalanced(t, e) {
        let n,
          r,
          o = t;
        t: for (; o < this.tokenCount && ((n = this.balance[o]), !(n < t)); o++)
          switch (((r = o > 0 ? this.offsetAndType[o - 1] & ie : this.firstCharOffset), e(this.source.charCodeAt(r)))) {
            case 1:
              break t;
            case 2:
              o++;
              break t;
            default:
              this.balance[n] === o && (o = n);
          }
        this.skip(o - this.tokenIndex);
      }
      forEachToken(t) {
        for (let e = 0, n = this.firstCharOffset; e < this.tokenCount; e++) {
          let r = n,
            o = this.offsetAndType[e],
            i = o & ie;
          (n = i), t(o >> se, r, i, e);
        }
      }
      dump() {
        let t = new Array(this.tokenCount);
        return (
          this.forEachToken((e, n, r, o) => {
            t[o] = { idx: o, type: ee[e], chunk: this.source.substring(n, r), balance: this.balance[o] };
          }),
          t
        );
      }
    };
  function ce(t, e) {
    function n(e) {
      return e < a ? t.charCodeAt(e) : 0;
    }
    function r() {
      return (
        (c = Xt(t, c)),
        Mt(n(c), n(c + 1), n(c + 2))
          ? ((s = 12), void (c = Yt(t, c)))
          : 37 === n(c)
          ? ((s = 11), void c++)
          : void (s = 10)
      );
    }
    function o() {
      let e = c;
      return (
        (c = Yt(t, c)),
        Ht(t, e, c, 'url') && 40 === n(c)
          ? ((c = Jt(t, c + 1)),
            34 === n(c) || 39 === n(c)
              ? ((s = 2), void (c = e + 4))
              : void (function () {
                  for (s = 7, c = Jt(t, c); c < t.length; c++) {
                    let e = t.charCodeAt(c);
                    switch (zt(e)) {
                      case 41:
                        return void c++;
                      case Ut:
                        return (
                          (c = Jt(t, c)),
                          41 === n(c) || c >= t.length ? void (c < t.length && c++) : ((c = Zt(t, c)), void (s = 8))
                        );
                      case 34:
                      case 39:
                      case 40:
                      case Vt:
                        return (c = Zt(t, c)), void (s = 8);
                      case 92:
                        if (jt(e, n(c + 1))) {
                          c = Qt(t, c) - 1;
                          break;
                        }
                        return (c = Zt(t, c)), void (s = 8);
                    }
                  }
                })())
          : 40 === n(c)
          ? ((s = 2), void c++)
          : void (s = 1)
      );
    }
    function i(e) {
      for (e || (e = n(c++)), s = 5; c < t.length; c++) {
        let r = t.charCodeAt(c);
        switch (zt(r)) {
          case e:
            return void c++;
          case Ut:
            if (It(r)) return (c += Wt(t, c, r)), void (s = 6);
            break;
          case 92:
            if (c === t.length - 1) break;
            let o = n(c + 1);
            It(o) ? (c += Wt(t, c + 1, o)) : jt(r, o) && (c = Qt(t, c) - 1);
        }
      }
    }
    let s,
      a = (t = String(t || '')).length,
      l = Rt(n(0)),
      c = l;
    for (; c < a; ) {
      let a = t.charCodeAt(c);
      switch (zt(a)) {
        case Ut:
          (s = 13), (c = Jt(t, c + 1));
          break;
        case 34:
          i();
          break;
        case 35:
          Ot(n(c + 1)) || jt(n(c + 1), n(c + 2)) ? ((s = 4), (c = Yt(t, c + 1))) : ((s = 9), c++);
          break;
        case 39:
          i();
          break;
        case 40:
          (s = 21), c++;
          break;
        case 41:
          (s = 22), c++;
          break;
        case 43:
          Dt(a, n(c + 1), n(c + 2)) ? r() : ((s = 9), c++);
          break;
        case 44:
          (s = 18), c++;
          break;
        case 45:
          Dt(a, n(c + 1), n(c + 2))
            ? r()
            : 45 === n(c + 1) && 62 === n(c + 2)
            ? ((s = 15), (c += 3))
            : Mt(a, n(c + 1), n(c + 2))
            ? o()
            : ((s = 9), c++);
          break;
        case 46:
          Dt(a, n(c + 1), n(c + 2)) ? r() : ((s = 9), c++);
          break;
        case 47:
          42 === n(c + 1)
            ? ((s = 25), (c = t.indexOf('*/', c + 2)), (c = -1 === c ? t.length : c + 2))
            : ((s = 9), c++);
          break;
        case 58:
          (s = 16), c++;
          break;
        case 59:
          (s = 17), c++;
          break;
        case 60:
          33 === n(c + 1) && 45 === n(c + 2) && 45 === n(c + 3) ? ((s = 14), (c += 4)) : ((s = 9), c++);
          break;
        case 64:
          Mt(n(c + 1), n(c + 2), n(c + 3)) ? ((s = 3), (c = Yt(t, c + 1))) : ((s = 9), c++);
          break;
        case 91:
          (s = 19), c++;
          break;
        case 92:
          jt(a, n(c + 1)) ? o() : ((s = 9), c++);
          break;
        case 93:
          (s = 20), c++;
          break;
        case 123:
          (s = 23), c++;
          break;
        case 125:
          (s = 24), c++;
          break;
        case $t:
          r();
          break;
        case Ft:
          o();
          break;
        default:
          (s = 9), c++;
      }
      e(s, l, (l = c));
    }
  }
  var ue,
    he =
      ((ue = At()),
      1,
      ((t, e, n, r) => {
        if ((e && 'object' == typeof e) || 'function' == typeof e)
          for (let n of mt(e))
            !kt.call(t, n) &&
              'default' !== n &&
              pt(t, n, { get: () => e[n], enumerable: !(r = ft(e, n)) || r.enumerable });
        return t;
      })(
        (t => pt(t, '__esModule', { value: !0 }))(
          pt(null != ue ? dt(gt(ue)) : {}, 'default', { value: ue, enumerable: !0 })
        ),
        ue
      )),
    de = new Set(['Atrule', 'Selector', 'Declaration']),
    pe = {};
  vt(pe, { safe: () => ve, spec: () => ye });
  var fe = (t, e) => {
      if ((9 === t && (t = e), 'string' == typeof t)) {
        let e = t.charCodeAt(0);
        return e > 127 ? 32768 : e << 8;
      }
      return t;
    },
    me = [
      [1, 1],
      [1, 2],
      [1, 7],
      [1, 8],
      [1, '-'],
      [1, 10],
      [1, 11],
      [1, 12],
      [1, 15],
      [1, 21],
      [3, 1],
      [3, 2],
      [3, 7],
      [3, 8],
      [3, '-'],
      [3, 10],
      [3, 11],
      [3, 12],
      [3, 15],
      [4, 1],
      [4, 2],
      [4, 7],
      [4, 8],
      [4, '-'],
      [4, 10],
      [4, 11],
      [4, 12],
      [4, 15],
      [12, 1],
      [12, 2],
      [12, 7],
      [12, 8],
      [12, '-'],
      [12, 10],
      [12, 11],
      [12, 12],
      [12, 15],
      ['#', 1],
      ['#', 2],
      ['#', 7],
      ['#', 8],
      ['#', '-'],
      ['#', 10],
      ['#', 11],
      ['#', 12],
      ['#', 15],
      ['-', 1],
      ['-', 2],
      ['-', 7],
      ['-', 8],
      ['-', '-'],
      ['-', 10],
      ['-', 11],
      ['-', 12],
      ['-', 15],
      [10, 1],
      [10, 2],
      [10, 7],
      [10, 8],
      [10, 10],
      [10, 11],
      [10, 12],
      [10, '%'],
      [10, 15],
      ['@', 1],
      ['@', 2],
      ['@', 7],
      ['@', 8],
      ['@', '-'],
      ['@', 15],
      ['.', 10],
      ['.', 11],
      ['.', 12],
      ['+', 10],
      ['+', 11],
      ['+', 12],
      ['/', '*']
    ],
    ge = me.concat([
      [1, 4],
      [12, 4],
      [4, 4],
      [3, 21],
      [3, 5],
      [3, 16],
      [11, 11],
      [11, 12],
      [11, 2],
      [11, '-'],
      [22, 1],
      [22, 2],
      [22, 11],
      [22, 12],
      [22, 4],
      [22, '-']
    ]);
  function ke(t) {
    let e = new Set(t.map(([t, e]) => (fe(t) << 16) | fe(e)));
    return function (t, n, r) {
      let o = fe(n, r),
        i = r.charCodeAt(0);
      return (
        ((45 === i && 1 !== n && 2 !== n && 15 !== n) || 43 === i
          ? e.has((t << 16) | (i << 8))
          : e.has((t << 16) | o)) && this.emit(' ', 13, !0),
        o
      );
    };
  }
  var ye = ke(me),
    ve = ke(ge);
  function be(t, e) {
    if ('function' != typeof e) t.children.forEach(this.node, this);
    else {
      let n = null;
      t.children.forEach(t => {
        null !== n && e.call(this, n), this.node(t), (n = t);
      });
    }
  }
  function Se(t) {
    ce(t, (e, n, r) => {
      this.token(e, t.slice(n, r));
    });
  }
  var Ce = {};
  vt(Ce, {
    AnPlusB: () => Ie,
    Atrule: () => Ne,
    AtrulePrelude: () => je,
    AttributeSelector: () => qe,
    Block: () => We,
    Brackets: () => Ge,
    CDC: () => He,
    CDO: () => Je,
    ClassSelector: () => Qe,
    Combinator: () => Xe,
    Comment: () => Ze,
    Declaration: () => tn,
    DeclarationList: () => en,
    Dimension: () => nn,
    Function: () => rn,
    Hash: () => on,
    IdSelector: () => cn,
    Identifier: () => an,
    MediaFeature: () => un,
    MediaQuery: () => hn,
    MediaQueryList: () => dn,
    NestingSelector: () => fn,
    Nth: () => gn,
    Number: () => kn,
    Operator: () => yn,
    Parentheses: () => vn,
    Percentage: () => Sn,
    PseudoClassSelector: () => wn,
    PseudoElementSelector: () => An,
    Ratio: () => _n,
    Raw: () => Tn,
    Rule: () => On,
    Selector: () => In,
    SelectorList: () => jn,
    String: () => $n,
    StyleSheet: () => Fn,
    TypeSelector: () => Wn,
    UnicodeRange: () => Gn,
    Url: () => Zn,
    Value: () => tr,
    WhiteSpace: () => er
  });
  var we = 43,
    xe = 45,
    Ae = 110,
    _e = !0;
  function Le(t, e) {
    let n = this.tokenStart + t,
      r = this.charCodeAt(n);
    for ((r === we || r === xe) && (e && this.error('Number sign is not allowed'), n++); n < this.tokenEnd; n++)
      _t(this.charCodeAt(n)) || this.error('Integer is expected', n);
  }
  function Ee(t) {
    return Le.call(this, 0, t);
  }
  function Te(t, e) {
    if (!this.cmpChar(this.tokenStart + t, e)) {
      let n = '';
      switch (e) {
        case Ae:
          n = 'N is expected';
          break;
        case xe:
          n = 'HyphenMinus is expected';
      }
      this.error(n, this.tokenStart + t);
    }
  }
  function Oe() {
    let t = 0,
      e = 0,
      n = this.tokenType;
    for (; 13 === n || 25 === n; ) n = this.lookupType(++t);
    if (10 !== n) {
      if (!this.isDelim(we, t) && !this.isDelim(xe, t)) return null;
      e = this.isDelim(we, t) ? we : xe;
      do {
        n = this.lookupType(++t);
      } while (13 === n || 25 === n);
      10 !== n && (this.skip(t), Ee.call(this, _e));
    }
    return (
      t > 0 && this.skip(t),
      0 === e &&
        ((n = this.charCodeAt(this.tokenStart)), n !== we && n !== xe && this.error('Number sign is expected')),
      Ee.call(this, 0 !== e),
      e === xe ? '-' + this.consume(10) : this.consume(10)
    );
  }
  function Pe() {
    let t = this.tokenStart,
      e = null,
      n = null;
    if (10 === this.tokenType) Ee.call(this, !1), (n = this.consume(10));
    else if (1 === this.tokenType && this.cmpChar(this.tokenStart, xe))
      switch (((e = '-1'), Te.call(this, 1, Ae), this.tokenEnd - this.tokenStart)) {
        case 2:
          this.next(), (n = Oe.call(this));
          break;
        case 3:
          Te.call(this, 2, xe), this.next(), this.skipSC(), Ee.call(this, _e), (n = '-' + this.consume(10));
          break;
        default:
          Te.call(this, 2, xe), Le.call(this, 3, _e), this.next(), (n = this.substrToCursor(t + 2));
      }
    else if (1 === this.tokenType || (this.isDelim(we) && 1 === this.lookupType(1))) {
      let r = 0;
      switch (
        ((e = '1'), this.isDelim(we) && ((r = 1), this.next()), Te.call(this, 0, Ae), this.tokenEnd - this.tokenStart)
      ) {
        case 1:
          this.next(), (n = Oe.call(this));
          break;
        case 2:
          Te.call(this, 1, xe), this.next(), this.skipSC(), Ee.call(this, _e), (n = '-' + this.consume(10));
          break;
        default:
          Te.call(this, 1, xe), Le.call(this, 2, _e), this.next(), (n = this.substrToCursor(t + r + 1));
      }
    } else if (12 === this.tokenType) {
      let r = this.charCodeAt(this.tokenStart),
        o = r === we || r === xe,
        i = this.tokenStart + o;
      for (; i < this.tokenEnd && _t(this.charCodeAt(i)); i++);
      i === this.tokenStart + o && this.error('Integer is expected', this.tokenStart + o),
        Te.call(this, i - this.tokenStart, Ae),
        (e = this.substring(t, i)),
        i + 1 === this.tokenEnd
          ? (this.next(), (n = Oe.call(this)))
          : (Te.call(this, i - this.tokenStart + 1, xe),
            i + 2 === this.tokenEnd
              ? (this.next(), this.skipSC(), Ee.call(this, _e), (n = '-' + this.consume(10)))
              : (Le.call(this, i - this.tokenStart + 2, _e), this.next(), (n = this.substrToCursor(i + 1))));
    } else this.error();
    return (
      null !== e && e.charCodeAt(0) === we && (e = e.substr(1)),
      null !== n && n.charCodeAt(0) === we && (n = n.substr(1)),
      { type: 'AnPlusB', loc: this.getLocation(t, this.tokenStart), a: e, b: n }
    );
  }
  function Ie(t) {
    if (t.a) {
      let e = ('+1' === t.a || '1' === t.a ? 'n' : '-1' === t.a && '-n') || t.a + 'n';
      if (t.b) {
        let n = '-' === t.b[0] || '+' === t.b[0] ? t.b : '+' + t.b;
        this.tokenize(e + n);
      } else this.tokenize(e);
    } else this.tokenize(t.b);
  }
  function Ne(t) {
    this.token(3, '@' + t.name),
      null !== t.prelude && this.node(t.prelude),
      t.block ? this.node(t.block) : this.token(17, ';');
  }
  function je(t) {
    this.children(t);
  }
  var Me = 36,
    De = 42,
    Re = 61,
    Be = 94,
    Ue = 124,
    $e = 126;
  function Fe() {
    this.eof && this.error('Unexpected end of input');
    let t = this.tokenStart,
      e = !1;
    return (
      this.isDelim(De) ? ((e = !0), this.next()) : this.isDelim(Ue) || this.eat(1),
      this.isDelim(Ue)
        ? this.charCodeAt(this.tokenStart + 1) !== Re
          ? (this.next(), this.eat(1))
          : e && this.error('Identifier is expected', this.tokenEnd)
        : e && this.error('Vertical line is expected'),
      { type: 'Identifier', loc: this.getLocation(t, this.tokenStart), name: this.substrToCursor(t) }
    );
  }
  function Ve() {
    let t = this.tokenStart,
      e = this.charCodeAt(t);
    return (
      e !== Re &&
        e !== $e &&
        e !== Be &&
        e !== Me &&
        e !== De &&
        e !== Ue &&
        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected'),
      this.next(),
      e !== Re && (this.isDelim(Re) || this.error('Equal sign is expected'), this.next()),
      this.substrToCursor(t)
    );
  }
  function ze() {
    let t,
      e = this.tokenStart,
      n = null,
      r = null,
      o = null;
    return (
      this.eat(19),
      this.skipSC(),
      (t = Fe.call(this)),
      this.skipSC(),
      20 !== this.tokenType &&
        (1 !== this.tokenType &&
          ((n = Ve.call(this)),
          this.skipSC(),
          (r = 5 === this.tokenType ? this.String() : this.Identifier()),
          this.skipSC()),
        1 === this.tokenType && ((o = this.consume(1)), this.skipSC())),
      this.eat(20),
      { type: 'AttributeSelector', loc: this.getLocation(e, this.tokenStart), name: t, matcher: n, value: r, flags: o }
    );
  }
  function qe(t) {
    this.token(9, '['),
      this.node(t.name),
      null !== t.matcher && (this.tokenize(t.matcher), this.node(t.value)),
      null !== t.flags && this.token(1, t.flags),
      this.token(9, ']');
  }
  function We(t) {
    this.token(23, '{'),
      this.children(t, t => {
        'Declaration' === t.type && this.token(17, ';');
      }),
      this.token(24, '}');
  }
  function Ge(t) {
    this.token(9, '['), this.children(t), this.token(9, ']');
  }
  function He() {
    this.token(15, '--\x3e');
  }
  function Je() {
    this.token(14, '\x3c!--');
  }
  function Ke() {
    return (
      this.eatDelim(46),
      { type: 'ClassSelector', loc: this.getLocation(this.tokenStart - 1, this.tokenEnd), name: this.consume(1) }
    );
  }
  function Qe(t) {
    this.token(9, '.'), this.token(1, t.name);
  }
  function Ye() {
    let t,
      e = this.tokenStart;
    switch (this.tokenType) {
      case 13:
        t = ' ';
        break;
      case 9:
        switch (this.charCodeAt(this.tokenStart)) {
          case 62:
          case 43:
          case 126:
            this.next();
            break;
          case 47:
            this.next(), this.eatIdent('deep'), this.eatDelim(47);
            break;
          default:
            this.error('Combinator is expected');
        }
        t = this.substrToCursor(e);
    }
    return { type: 'Combinator', loc: this.getLocation(e, this.tokenStart), name: t };
  }
  function Xe(t) {
    this.tokenize(t.name);
  }
  function Ze(t) {
    this.token(25, '/*' + t.value + '*/');
  }
  function tn(t) {
    this.token(1, t.property),
      this.token(16, ':'),
      this.node(t.value),
      t.important && (this.token(9, '!'), this.token(1, !0 === t.important ? 'important' : t.important));
  }
  function en(t) {
    this.children(t, t => {
      'Declaration' === t.type && this.token(17, ';');
    });
  }
  function nn(t) {
    this.token(12, t.value + t.unit);
  }
  function rn(t) {
    this.token(2, t.name + '('), this.children(t), this.token(22, ')');
  }
  function on(t) {
    this.token(4, '#' + t.value);
  }
  function sn() {
    return { type: 'Identifier', loc: this.getLocation(this.tokenStart, this.tokenEnd), name: this.consume(1) };
  }
  function an(t) {
    this.token(1, t.name);
  }
  function ln() {
    let t = this.tokenStart;
    return (
      this.eat(4), { type: 'IdSelector', loc: this.getLocation(t, this.tokenStart), name: this.substrToCursor(t + 1) }
    );
  }
  function cn(t) {
    this.token(9, '#' + t.name);
  }
  function un(t) {
    this.token(21, '('),
      this.token(1, t.name),
      null !== t.value && (this.token(16, ':'), this.node(t.value)),
      this.token(22, ')');
  }
  function hn(t) {
    this.children(t);
  }
  function dn(t) {
    this.children(t, () => this.token(18, ','));
  }
  function pn() {
    let t = this.tokenStart;
    return this.eatDelim(38), { type: 'NestingSelector', loc: this.getLocation(t, this.tokenStart) };
  }
  function fn() {
    this.token(9, '&');
  }
  function mn() {
    this.skipSC();
    let t,
      e = this.tokenStart,
      n = e,
      r = null;
    return (
      (t = this.lookupValue(0, 'odd') || this.lookupValue(0, 'even') ? this.Identifier() : this.AnPlusB()),
      (n = this.tokenStart),
      this.skipSC(),
      this.lookupValue(0, 'of') && (this.next(), (r = this.SelectorList()), (n = this.tokenStart)),
      { type: 'Nth', loc: this.getLocation(e, n), nth: t, selector: r }
    );
  }
  function gn(t) {
    this.node(t.nth), null !== t.selector && (this.token(1, 'of'), this.node(t.selector));
  }
  function kn(t) {
    this.token(10, t.value);
  }
  function yn(t) {
    this.tokenize(t.value);
  }
  function vn(t) {
    this.token(21, '('), this.children(t), this.token(22, ')');
  }
  function bn() {
    return { type: 'Percentage', loc: this.getLocation(this.tokenStart, this.tokenEnd), value: this.consumeNumber(11) };
  }
  function Sn(t) {
    this.token(11, t.value + '%');
  }
  function Cn() {
    let t,
      e,
      n = this.tokenStart,
      r = null;
    return (
      this.eat(16),
      2 === this.tokenType
        ? ((t = this.consumeFunctionName()),
          (e = t.toLowerCase()),
          hasOwnProperty.call(this.pseudo, e)
            ? (this.skipSC(), (r = this.pseudo[e].call(this)), this.skipSC())
            : ((r = this.createList()), r.push(this.Raw(this.tokenIndex, null, !1))),
          this.eat(22))
        : (t = this.consume(1)),
      { type: 'PseudoClassSelector', loc: this.getLocation(n, this.tokenStart), name: t, children: r }
    );
  }
  function wn(t) {
    this.token(16, ':'),
      null === t.children
        ? this.token(1, t.name)
        : (this.token(2, t.name + '('), this.children(t), this.token(22, ')'));
  }
  function xn() {
    let t,
      e,
      n = this.tokenStart,
      r = null;
    return (
      this.eat(16),
      this.eat(16),
      2 === this.tokenType
        ? ((t = this.consumeFunctionName()),
          (e = t.toLowerCase()),
          hasOwnProperty.call(this.pseudo, e)
            ? (this.skipSC(), (r = this.pseudo[e].call(this)), this.skipSC())
            : ((r = this.createList()), r.push(this.Raw(this.tokenIndex, null, !1))),
          this.eat(22))
        : (t = this.consume(1)),
      { type: 'PseudoElementSelector', loc: this.getLocation(n, this.tokenStart), name: t, children: r }
    );
  }
  function An(t) {
    this.token(16, ':'),
      this.token(16, ':'),
      null === t.children
        ? this.token(1, t.name)
        : (this.token(2, t.name + '('), this.children(t), this.token(22, ')'));
  }
  function _n(t) {
    this.token(10, t.left), this.token(9, '/'), this.token(10, t.right);
  }
  function Ln() {
    return this.tokenIndex > 0 && 13 === this.lookupType(-1)
      ? this.tokenIndex > 1
        ? this.getTokenStart(this.tokenIndex - 1)
        : this.firstCharOffset
      : this.tokenStart;
  }
  function En(t, e, n) {
    let r,
      o = this.getTokenStart(t);
    return (
      this.skipUntilBalanced(t, e || this.consumeUntilBalanceEnd),
      (r = n && this.tokenStart > o ? Ln.call(this) : this.tokenStart),
      { type: 'Raw', loc: this.getLocation(o, r), value: this.substring(o, r) }
    );
  }
  function Tn(t) {
    this.tokenize(t.value);
  }
  function On(t) {
    this.node(t.prelude), this.node(t.block);
  }
  function Pn() {
    let t = this.readSequence(this.scope.Selector);
    return (
      null === this.getFirstListNode(t) && this.error('Selector is expected'),
      { type: 'Selector', loc: this.getLocationFromList(t), children: t }
    );
  }
  function In(t) {
    this.children(t);
  }
  function Nn() {
    let t = this.createList();
    for (; !this.eof && (t.push(this.Selector()), 18 === this.tokenType); ) this.next();
    return { type: 'SelectorList', loc: this.getLocationFromList(t), children: t };
  }
  function jn(t) {
    this.children(t, () => this.token(18, ','));
  }
  var Mn = 92,
    Dn = 34,
    Rn = 39;
  function Bn(t) {
    let e = t.length,
      n = t.charCodeAt(0),
      r = n === Dn || n === Rn ? 1 : 0,
      o = 1 === r && e > 1 && t.charCodeAt(e - 1) === n ? e - 2 : e - 1,
      i = '';
    for (let n = r; n <= o; n++) {
      let r = t.charCodeAt(n);
      if (r === Mn) {
        if (n === o) {
          n !== e - 1 && (i = t.substr(n + 1));
          break;
        }
        if (((r = t.charCodeAt(++n)), jt(Mn, r))) {
          let e = n - 1,
            r = Qt(t, e);
          (n = r - 1), (i += te(t.substring(e + 1, r)));
        } else 13 === r && 10 === t.charCodeAt(n + 1) && n++;
      } else i += t[n];
    }
    return i;
  }
  function Un() {
    return { type: 'String', loc: this.getLocation(this.tokenStart, this.tokenEnd), value: Bn(this.consume(5)) };
  }
  function $n(t) {
    this.token(
      5,
      (function (t, e) {
        let n = Dn,
          r = '',
          o = !1;
        for (let e = 0; e < t.length; e++) {
          let i = t.charCodeAt(e);
          0 !== i
            ? i <= 31 || 127 === i
              ? ((r += '\\' + i.toString(16)), (o = !0))
              : i === n || i === Mn
              ? ((r += '\\' + t.charAt(e)), (o = !1))
              : (o && (Lt(i) || Nt(i)) && (r += ' '), (r += t.charAt(e)), (o = !1))
            : (r += '\ufffd');
        }
        return '"' + r + '"';
      })(t.value)
    );
  }
  function Fn(t) {
    this.children(t);
  }
  var Vn = 42;
  function zn() {
    1 !== this.tokenType && !1 === this.isDelim(Vn) && this.error('Identifier or asterisk is expected'), this.next();
  }
  function qn() {
    let t = this.tokenStart;
    return (
      this.isDelim(124)
        ? (this.next(), zn.call(this))
        : (zn.call(this), this.isDelim(124) && (this.next(), zn.call(this))),
      { type: 'TypeSelector', loc: this.getLocation(t, this.tokenStart), name: this.substrToCursor(t) }
    );
  }
  function Wn(t) {
    this.tokenize(t.name);
  }
  function Gn(t) {
    this.tokenize(t.value);
  }
  var Hn = 32,
    Jn = 92,
    Kn = 34,
    Qn = 39,
    Yn = 40,
    Xn = 41;
  function Zn(t) {
    this.token(
      7,
      (function (t) {
        let e = '',
          n = !1;
        for (let r = 0; r < t.length; r++) {
          let o = t.charCodeAt(r);
          0 !== o
            ? o <= 31 || 127 === o
              ? ((e += '\\' + o.toString(16)), (n = !0))
              : o === Hn || o === Jn || o === Kn || o === Qn || o === Yn || o === Xn
              ? ((e += '\\' + t.charAt(r)), (n = !1))
              : (n && Lt(o) && (e += ' '), (e += t.charAt(r)), (n = !1))
            : (e += '\ufffd');
        }
        return 'url(' + e + ')';
      })(t.value)
    );
  }
  function tr(t) {
    this.children(t);
  }
  function er(t) {
    this.token(13, t.value);
  }
  var nr = (function (t) {
      let e = new Map();
      for (let n in t.node) {
        let r = t.node[n];
        'function' == typeof (r.generate || r) && e.set(n, r.generate || r);
      }
      return function (t, n) {
        let r = '',
          o = 0,
          i = {
            node(t) {
              if (!e.has(t.type)) throw new Error('Unknown node type: ' + t.type);
              e.get(t.type).call(s, t);
            },
            tokenBefore: ve,
            token(t, e) {
              (o = this.tokenBefore(o, t, e)),
                this.emit(e, t, !1),
                9 === t && 92 === e.charCodeAt(0) && this.emit('\n', 13, !0);
            },
            emit(t) {
              r += t;
            },
            result: () => r
          };
        n &&
          ('function' == typeof n.decorator && (i = n.decorator(i)),
          n.sourceMap &&
            (i = (function (t) {
              let e = new he.SourceMapGenerator(),
                n = { line: 1, column: 0 },
                r = { line: 0, column: 0 },
                o = { line: 1, column: 0 },
                i = { generated: o },
                s = 1,
                a = 0,
                l = !1,
                c = t.node;
              t.node = function (t) {
                if (t.loc && t.loc.start && de.has(t.type)) {
                  let c = t.loc.start.line,
                    u = t.loc.start.column - 1;
                  (r.line !== c || r.column !== u) &&
                    ((r.line = c),
                    (r.column = u),
                    (n.line = s),
                    (n.column = a),
                    l && ((l = !1), (n.line !== o.line || n.column !== o.column) && e.addMapping(i)),
                    (l = !0),
                    e.addMapping({ source: t.loc.source, original: r, generated: n }));
                }
                c.call(this, t), l && de.has(t.type) && ((o.line = s), (o.column = a));
              };
              let u = t.emit;
              t.emit = function (t, e, n) {
                for (let e = 0; e < t.length; e++) 10 === t.charCodeAt(e) ? (s++, (a = 0)) : a++;
                u(t, e, n);
              };
              let h = t.result;
              return (
                (t.result = function () {
                  return l && e.addMapping(i), { css: h(), map: e };
                }),
                t
              );
            })(i)),
          n.mode in pe && (i.tokenBefore = pe[n.mode]));
        let s = { node: t => i.node(t), children: be, token: (t, e) => i.token(t, e), tokenize: Se };
        return i.node(t), i.result();
      };
    })({ node: Ce }),
    rr = null,
    or = class {
      static createItem(t) {
        return { prev: null, next: null, data: t };
      }
      constructor() {
        (this.head = null), (this.tail = null), (this.cursor = null);
      }
      createItem(t) {
        return or.createItem(t);
      }
      allocateCursor(t, e) {
        let n;
        return (
          null !== rr
            ? ((n = rr), (rr = rr.cursor), (n.prev = t), (n.next = e), (n.cursor = this.cursor))
            : (n = { prev: t, next: e, cursor: this.cursor }),
          (this.cursor = n),
          n
        );
      }
      releaseCursor() {
        let { cursor: t } = this;
        (this.cursor = t.cursor), (t.prev = null), (t.next = null), (t.cursor = rr), (rr = t);
      }
      updateCursors(t, e, n, r) {
        let { cursor: o } = this;
        for (; null !== o; ) o.prev === t && (o.prev = e), o.next === n && (o.next = r), (o = o.cursor);
      }
      *[Symbol.iterator]() {
        for (let t = this.head; null !== t; t = t.next) yield t.data;
      }
      get size() {
        let t = 0;
        for (let e = this.head; null !== e; e = e.next) t++;
        return t;
      }
      get isEmpty() {
        return null === this.head;
      }
      get first() {
        return this.head && this.head.data;
      }
      get last() {
        return this.tail && this.tail.data;
      }
      fromArray(t) {
        let e = null;
        this.head = null;
        for (let n of t) {
          let t = or.createItem(n);
          null !== e ? (e.next = t) : (this.head = t), (t.prev = e), (e = t);
        }
        return (this.tail = e), this;
      }
      toArray() {
        return [...this];
      }
      toJSON() {
        return [...this];
      }
      forEach(t, e = this) {
        let n = this.allocateCursor(null, this.head);
        for (; null !== n.next; ) {
          let r = n.next;
          (n.next = r.next), t.call(e, r.data, r, this);
        }
        this.releaseCursor();
      }
      forEachRight(t, e = this) {
        let n = this.allocateCursor(this.tail, null);
        for (; null !== n.prev; ) {
          let r = n.prev;
          (n.prev = r.prev), t.call(e, r.data, r, this);
        }
        this.releaseCursor();
      }
      reduce(t, e, n = this) {
        let r,
          o = this.allocateCursor(null, this.head),
          i = e;
        for (; null !== o.next; ) (r = o.next), (o.next = r.next), (i = t.call(n, i, r.data, r, this));
        return this.releaseCursor(), i;
      }
      reduceRight(t, e, n = this) {
        let r,
          o = this.allocateCursor(this.tail, null),
          i = e;
        for (; null !== o.prev; ) (r = o.prev), (o.prev = r.prev), (i = t.call(n, i, r.data, r, this));
        return this.releaseCursor(), i;
      }
      some(t, e = this) {
        for (let n = this.head; null !== n; n = n.next) if (t.call(e, n.data, n, this)) return !0;
        return !1;
      }
      map(t, e = this) {
        let n = new or();
        for (let r = this.head; null !== r; r = r.next) n.appendData(t.call(e, r.data, r, this));
        return n;
      }
      filter(t, e = this) {
        let n = new or();
        for (let r = this.head; null !== r; r = r.next) t.call(e, r.data, r, this) && n.appendData(r.data);
        return n;
      }
      nextUntil(t, e, n = this) {
        if (null === t) return;
        let r = this.allocateCursor(null, t);
        for (; null !== r.next; ) {
          let t = r.next;
          if (((r.next = t.next), e.call(n, t.data, t, this))) break;
        }
        this.releaseCursor();
      }
      prevUntil(t, e, n = this) {
        if (null === t) return;
        let r = this.allocateCursor(t, null);
        for (; null !== r.prev; ) {
          let t = r.prev;
          if (((r.prev = t.prev), e.call(n, t.data, t, this))) break;
        }
        this.releaseCursor();
      }
      clear() {
        (this.head = null), (this.tail = null);
      }
      copy() {
        let t = new or();
        for (let e of this) t.appendData(e);
        return t;
      }
      prepend(t) {
        return (
          this.updateCursors(null, t, this.head, t),
          null !== this.head ? ((this.head.prev = t), (t.next = this.head)) : (this.tail = t),
          (this.head = t),
          this
        );
      }
      prependData(t) {
        return this.prepend(or.createItem(t));
      }
      append(t) {
        return this.insert(t);
      }
      appendData(t) {
        return this.insert(or.createItem(t));
      }
      insert(t, e = null) {
        if (null !== e)
          if ((this.updateCursors(e.prev, t, e, t), null === e.prev)) {
            if (this.head !== e) throw new Error("before doesn't belong to list");
            (this.head = t), (e.prev = t), (t.next = e), this.updateCursors(null, t);
          } else (e.prev.next = t), (t.prev = e.prev), (e.prev = t), (t.next = e);
        else
          this.updateCursors(this.tail, t, null, t),
            null !== this.tail ? ((this.tail.next = t), (t.prev = this.tail)) : (this.head = t),
            (this.tail = t);
        return this;
      }
      insertData(t, e) {
        return this.insert(or.createItem(t), e);
      }
      remove(t) {
        if ((this.updateCursors(t, t.prev, t, t.next), null !== t.prev)) t.prev.next = t.next;
        else {
          if (this.head !== t) throw new Error("item doesn't belong to list");
          this.head = t.next;
        }
        if (null !== t.next) t.next.prev = t.prev;
        else {
          if (this.tail !== t) throw new Error("item doesn't belong to list");
          this.tail = t.prev;
        }
        return (t.prev = null), (t.next = null), t;
      }
      push(t) {
        this.insert(or.createItem(t));
      }
      pop() {
        return null !== this.tail ? this.remove(this.tail) : null;
      }
      unshift(t) {
        this.prepend(or.createItem(t));
      }
      shift() {
        return null !== this.head ? this.remove(this.head) : null;
      }
      prependList(t) {
        return this.insertList(t, this.head);
      }
      appendList(t) {
        return this.insertList(t);
      }
      insertList(t, e) {
        return (
          null === t.head ||
            (null != e
              ? (this.updateCursors(e.prev, t.tail, e, t.head),
                null !== e.prev ? ((e.prev.next = t.head), (t.head.prev = e.prev)) : (this.head = t.head),
                (e.prev = t.tail),
                (t.tail.next = e))
              : (this.updateCursors(this.tail, t.tail, null, t.head),
                null !== this.tail ? ((this.tail.next = t.head), (t.head.prev = this.tail)) : (this.head = t.head),
                (this.tail = t.tail)),
            (t.head = null),
            (t.tail = null)),
          this
        );
      }
      replace(t, e) {
        'head' in e ? this.insertList(e, t) : this.insert(e, t), this.remove(t);
      }
    },
    ir = 100,
    sr = 60,
    ar = '    ';
  function lr({ source: t, line: e, column: n }, r) {
    function o(t, e) {
      return i
        .slice(t, e)
        .map((e, n) => String(t + n + 1).padStart(l) + ' |' + e)
        .join('\n');
    }
    let i = t.split(/\r\n?|\n|\f/),
      s = Math.max(1, e - r) - 1,
      a = Math.min(e + r, i.length + 1),
      l = Math.max(4, String(a).length) + 1,
      c = 0;
    (n += (ar.length - 1) * (i[e - 1].substr(0, n - 1).match(/\t/g) || []).length) > ir &&
      ((c = n - sr + 3), (n = sr - 2));
    for (let t = s; t <= a; t++)
      t >= 0 &&
        t < i.length &&
        ((i[t] = i[t].replace(/\t/g, ar)),
        (i[t] =
          (c > 0 && i[t].length > c ? '\u2026' : '') +
          i[t].substr(c, ir - 2) +
          (i[t].length > c + ir - 1 ? '\u2026' : '')));
    return [o(s, e), new Array(n + l + 2).join('-') + '^', o(e, a)].filter(Boolean).join('\n');
  }
  function cr(t, e, n, r, o) {
    return Object.assign(
      (function (t, e) {
        let n = Object.create(SyntaxError.prototype),
          r = new Error();
        return Object.assign(n, {
          name: t,
          message: e,
          get stack() {
            return (r.stack || '').replace(/^(.+\n){1,3}/, `${t}: ${e}\n`);
          }
        });
      })('SyntaxError', t),
      {
        source: e,
        offset: n,
        line: r,
        column: o,
        sourceFragment: t => lr({ source: e, line: r, column: o }, isNaN(t) ? 0 : t),
        get formattedMessage() {
          return `Parse error: ${t}\n` + lr({ source: e, line: r, column: o }, 2);
        }
      }
    );
  }
  function ur(t) {
    let e = this.createList(),
      n = !1,
      r = { recognizer: t };
    for (; !this.eof; ) {
      switch (this.tokenType) {
        case 25:
          this.next();
          continue;
        case 13:
          (n = !0), this.next();
          continue;
      }
      let o = t.getNode.call(this, r);
      if (void 0 === o) break;
      n && (t.onWhiteSpace && t.onWhiteSpace.call(this, o, e, r), (n = !1)), e.push(o);
    }
    return n && t.onWhiteSpace && t.onWhiteSpace.call(this, null, e, r), e;
  }
  var hr = () => {};
  function dr(t) {
    return function () {
      return this[t]();
    };
  }
  function pr(t) {
    let e = Object.create(null);
    for (let n in t) {
      let r = t[n],
        o = r.parse || r;
      o && (e[n] = o);
    }
    return e;
  }
  var fr = {
      parse() {
        return this.createSingleNodeList(this.SelectorList());
      }
    },
    mr = {
      parse() {
        return this.createSingleNodeList(this.Selector());
      }
    },
    gr = {
      parse() {
        return this.createSingleNodeList(this.Identifier());
      }
    },
    kr = {
      parse() {
        return this.createSingleNodeList(this.Nth());
      }
    },
    yr = {
      dir: gr,
      has: fr,
      lang: gr,
      matches: fr,
      is: fr,
      '-moz-any': fr,
      '-webkit-any': fr,
      where: fr,
      not: fr,
      'nth-child': kr,
      'nth-last-child': kr,
      'nth-last-of-type': kr,
      'nth-of-type': kr,
      slotted: mr,
      host: mr,
      'host-context': mr
    },
    vr = {};
  vt(vr, {
    AnPlusB: () => Pe,
    AttributeSelector: () => ze,
    ClassSelector: () => Ke,
    Combinator: () => Ye,
    IdSelector: () => ln,
    Identifier: () => sn,
    NestingSelector: () => pn,
    Nth: () => mn,
    Percentage: () => bn,
    PseudoClassSelector: () => Cn,
    PseudoElementSelector: () => xn,
    Raw: () => En,
    Selector: () => Pn,
    SelectorList: () => Nn,
    String: () => Un,
    TypeSelector: () => qn
  });
  var br = (function (t) {
      let e = '',
        n = '<unknown>',
        r = !1,
        o = hr,
        i = !1,
        s = new oe(),
        a = Object.assign(
          new le(),
          (function (t) {
            let e = {
              context: Object.create(null),
              scope: Object.assign(Object.create(null), t.scope),
              atrule: pr(t.atrule),
              pseudo: pr(t.pseudo),
              node: pr(t.node)
            };
            for (let n in t.parseContext)
              switch (typeof t.parseContext[n]) {
                case 'function':
                  e.context[n] = t.parseContext[n];
                  break;
                case 'string':
                  e.context[n] = dr(t.parseContext[n]);
              }
            return { config: e, ...e, ...e.node };
          })(t || {}),
          {
            parseAtrulePrelude: !0,
            parseRulePrelude: !0,
            parseValue: !0,
            parseCustomProperty: !1,
            readSequence: ur,
            consumeUntilBalanceEnd: () => 0,
            consumeUntilLeftCurlyBracket: t => (123 === t ? 1 : 0),
            consumeUntilLeftCurlyBracketOrSemicolon: t => (123 === t || 59 === t ? 1 : 0),
            consumeUntilExclamationMarkOrSemicolon: t => (33 === t || 59 === t ? 1 : 0),
            consumeUntilSemicolonIncluded: t => (59 === t ? 2 : 0),
            createList: () => new or(),
            createSingleNodeList: t => new or().appendData(t),
            getFirstListNode: t => t && t.first,
            getLastListNode: t => t && t.last,
            parseWithFallback(t, e) {
              let n = this.tokenIndex;
              try {
                return t.call(this);
              } catch (t) {
                if (i) throw t;
                let r = e.call(this, n);
                return (i = !0), o(t, r), (i = !1), r;
              }
            },
            lookupNonWSType(t) {
              let e;
              do {
                if (((e = this.lookupType(t++)), 13 !== e)) return e;
              } while (0 !== e);
              return 0;
            },
            charCodeAt: t => (t >= 0 && t < e.length ? e.charCodeAt(t) : 0),
            substring: (t, n) => e.substring(t, n),
            substrToCursor(t) {
              return this.source.substring(t, this.tokenStart);
            },
            cmpChar: (t, n) => Gt(e, t, n),
            cmpStr: (t, n, r) => Ht(e, t, n, r),
            consume(t) {
              let e = this.tokenStart;
              return this.eat(t), this.substrToCursor(e);
            },
            consumeFunctionName() {
              let t = e.substring(this.tokenStart, this.tokenEnd - 1);
              return this.eat(2), t;
            },
            consumeNumber(t) {
              let n = e.substring(this.tokenStart, Xt(e, this.tokenStart));
              return this.eat(t), n;
            },
            eat(t) {
              if (this.tokenType !== t) {
                let e = ee[t]
                    .slice(0, -6)
                    .replace(/-/g, ' ')
                    .replace(/^./, t => t.toUpperCase()),
                  n = `${/[[\](){}]/.test(e) ? `"${e}"` : e} is expected`,
                  r = this.tokenStart;
                switch (t) {
                  case 1:
                    2 === this.tokenType || 7 === this.tokenType
                      ? ((r = this.tokenEnd - 1), (n = 'Identifier is expected but function found'))
                      : (n = 'Identifier is expected');
                    break;
                  case 4:
                    this.isDelim(35) && (this.next(), r++, (n = 'Name is expected'));
                    break;
                  case 11:
                    10 === this.tokenType && ((r = this.tokenEnd), (n = 'Percent sign is expected'));
                }
                this.error(n, r);
              }
              this.next();
            },
            eatIdent(t) {
              (1 !== this.tokenType || !1 === this.lookupValue(0, t)) && this.error(`Identifier "${t}" is expected`),
                this.next();
            },
            eatDelim(t) {
              this.isDelim(t) || this.error(`Delim "${String.fromCharCode(t)}" is expected`), this.next();
            },
            getLocation: (t, e) => (r ? s.getLocationRange(t, e, n) : null),
            getLocationFromList(t) {
              if (r) {
                let e = this.getFirstListNode(t),
                  r = this.getLastListNode(t);
                return s.getLocationRange(
                  null !== e ? e.loc.start.offset - s.startOffset : this.tokenStart,
                  null !== r ? r.loc.end.offset - s.startOffset : this.tokenStart,
                  n
                );
              }
              return null;
            },
            error(t, n) {
              let r =
                typeof n < 'u' && n < e.length
                  ? s.getLocation(n)
                  : this.eof
                  ? s.getLocation(
                      (function (t, e) {
                        for (; e >= 0 && Nt(t.charCodeAt(e)); e--);
                        return e + 1;
                      })(e, e.length - 1)
                    )
                  : s.getLocation(this.tokenStart);
              throw new cr(t || 'Unexpected input', e, r.offset, r.line, r.column);
            }
          }
        );
      return Object.assign(
        function (t, l) {
          (e = t),
            (l = l || {}),
            a.setSource(e, ce),
            s.setSource(e, l.offset, l.line, l.column),
            (n = l.filename || '<unknown>'),
            (r = Boolean(l.positions)),
            (o = 'function' == typeof l.onParseError ? l.onParseError : hr),
            (i = !1),
            (a.parseAtrulePrelude = !('parseAtrulePrelude' in l) || Boolean(l.parseAtrulePrelude)),
            (a.parseRulePrelude = !('parseRulePrelude' in l) || Boolean(l.parseRulePrelude)),
            (a.parseValue = !('parseValue' in l) || Boolean(l.parseValue)),
            (a.parseCustomProperty = 'parseCustomProperty' in l && Boolean(l.parseCustomProperty));
          let { context: c = 'default', onComment: u } = l;
          if (!(c in a.context)) throw new Error('Unknown context `' + c + '`');
          'function' == typeof u &&
            a.forEachToken((t, n, r) => {
              if (25 === t) {
                let t = a.getLocation(n, r),
                  o = Ht(e, r - 2, r, '*/') ? e.slice(n + 2, r - 2) : e.slice(n + 2, r);
                u(o, t);
              }
            });
          let h = a.context[c].call(a, l);
          return a.eof || a.error(), h;
        },
        { SyntaxError: cr, config: a.config }
      );
    })({
      parseContext: { default: 'SelectorList', selectorList: 'SelectorList', selector: 'Selector' },
      scope: {
        Selector: {
          onWhiteSpace: function (t, e) {
            null !== e.last &&
              'Combinator' !== e.last.type &&
              null !== t &&
              'Combinator' !== t.type &&
              e.push({ type: 'Combinator', loc: null, name: ' ' });
          },
          getNode: function () {
            switch (this.tokenType) {
              case 19:
                return this.AttributeSelector();
              case 4:
                return this.IdSelector();
              case 16:
                return 16 === this.lookupType(1) ? this.PseudoElementSelector() : this.PseudoClassSelector();
              case 1:
                return this.TypeSelector();
              case 10:
              case 11:
                return this.Percentage();
              case 12:
                46 === this.charCodeAt(this.tokenStart) && this.error('Identifier is expected', this.tokenStart + 1);
                break;
              case 9:
                switch (this.charCodeAt(this.tokenStart)) {
                  case 43:
                  case 62:
                  case 126:
                  case 47:
                    return this.Combinator();
                  case 46:
                    return this.ClassSelector();
                  case 42:
                  case 124:
                    return this.TypeSelector();
                  case 35:
                    return this.IdSelector();
                  case 38:
                    return this.NestingSelector();
                }
            }
          }
        }
      },
      atrule: {},
      pseudo: yr,
      node: vr
    }),
    Sr = (t, e) => (t.a === e.a ? (t.b === e.b ? t.c - e.c : t.b - e.b) : t.a - e.a),
    Cr = (t, e) => 0 === Sr(t, e),
    wr = (t, e) => Sr(t, e) > 0,
    xr = (t, e) => Sr(t, e) < 0,
    Ar = (t, e = 'ASC') => {
      let n = t.sort(Sr);
      return 'DESC' === e ? n.reverse() : n;
    },
    _r = (...t) => Ar(t, 'ASC'),
    Lr = (...t) => Ar(t, 'DESC'),
    Er = (...t) => Lr(...t)[0],
    Tr = t => {
      let e = { a: 0, b: 0, c: 0 };
      return (
        t.children.forEach(t => {
          switch (t.type) {
            case 'IdSelector':
              e.a += 1;
              break;
            case 'AttributeSelector':
            case 'ClassSelector':
              e.b += 1;
              break;
            case 'PseudoClassSelector':
              switch (t.name.toLowerCase()) {
                case 'where':
                  break;
                case 'is':
                case 'matches':
                case '-webkit-any':
                case '-moz-any':
                case 'any':
                case 'not':
                case 'has':
                  if (t.children) {
                    let n = Er(...Or(t.children.first));
                    (e.a += n.a), (e.b += n.b), (e.c += n.c);
                  }
                  break;
                case 'nth-child':
                case 'nth-last-child':
                  if (((e.b += 1), t.children.first.selector)) {
                    let n = Er(...Or(t.children.first.selector));
                    (e.a += n.a), (e.b += n.b), (e.c += n.c);
                  }
                  break;
                case 'host-context':
                case 'host':
                  if (((e.b += 1), t.children)) {
                    let n = { type: 'Selector', children: [] },
                      r = !1;
                    t.children.first.children.forEach(
                      t => !r && ('Combinator' === t.type ? ((r = !0), !1) : void n.children.push(t))
                    );
                    let o = Or(n)[0];
                    (e.a += o.a), (e.b += o.b), (e.c += o.c);
                  }
                  break;
                case 'after':
                case 'before':
                case 'first-letter':
                case 'first-line':
                  e.c += 1;
                  break;
                default:
                  e.b += 1;
              }
              break;
            case 'PseudoElementSelector':
              switch (t.name) {
                case 'slotted':
                  if (((e.c += 1), t.children)) {
                    let n = { type: 'Selector', children: [] },
                      r = !1;
                    t.children.first.children.forEach(
                      t => !r && ('Combinator' === t.type ? ((r = !0), !1) : void n.children.push(t))
                    );
                    let o = Or(n)[0];
                    (e.a += o.a), (e.b += o.b), (e.c += o.c);
                  }
                  break;
                case 'view-transition-group':
                case 'view-transition-image-pair':
                case 'view-transition-old':
                case 'view-transition-new':
                  if (t.children && '*' === t.children.first.value) break;
                  e.c += 1;
                  break;
                default:
                  e.c += 1;
              }
              break;
            case 'TypeSelector':
              let n = t.name;
              n.includes('|') && (n = n.split('|')[1]), '*' !== n && (e.c += 1);
          }
        }),
        new Pr(e, t)
      );
    },
    Or = t => {
      if (!t) return [];
      let e = (t => {
        if ('string' == typeof t || t instanceof String)
          try {
            return br(t, { context: 'selectorList' });
          } catch (e) {
            throw new TypeError(`Could not convert passed in source '${t}' to SelectorList: ${e.message}`);
          }
        if (t instanceof Object) {
          if (t.type && ['Selector', 'SelectorList'].includes(t.type)) return t;
          if (t.type && 'Raw' === t.type)
            try {
              return br(t.value, { context: 'selectorList' });
            } catch (t) {
              throw new TypeError(`Could not convert passed in source to SelectorList: ${t.message}`);
            }
          throw new TypeError('Passed in source is an Object but no AST / AST of the type Selector or SelectorList');
        }
        throw new TypeError("Passed in source is not a String nor an Object. I don't know what to do with it.");
      })(t);
      if ('Selector' === e.type) return [Tr(t)];
      if ('SelectorList' === e.type) {
        let t = [];
        return (
          e.children.forEach(e => {
            let n = Tr(e);
            t.push(n);
          }),
          t
        );
      }
    },
    Pr = class {
      constructor(t, e = null) {
        (this.value = t), (this.selector = e);
      }
      get a() {
        return this.value.a;
      }
      set a(t) {
        throw new Error(
          'Manipulating the port of the specificity directly is not allowed. Instead, directly set a new value'
        );
      }
      get b() {
        return this.value.b;
      }
      set b(t) {
        throw new Error(
          'Manipulating the port of the specificity directly is not allowed. Instead, directly set a new value'
        );
      }
      get c() {
        return this.value.c;
      }
      set c(t) {
        throw new Error(
          'Manipulating the port of the specificity directly is not allowed. Instead, directly set a new value'
        );
      }
      selectorString() {
        return 'string' == typeof this.selector || this.selector instanceof String
          ? this.selector
          : this.selector instanceof Object && 'Selector' === this.selector.type
          ? nr(this.selector)
          : '';
      }
      toObject() {
        return this.value;
      }
      toArray() {
        return [this.value.a, this.value.b, this.value.c];
      }
      toString() {
        return `(${this.value.a},${this.value.b},${this.value.c})`;
      }
      toJSON() {
        return {
          selector: this.selectorString(),
          asObject: this.toObject(),
          asArray: this.toArray(),
          asString: this.toString()
        };
      }
      isEqualTo(t) {
        return Cr(this, t);
      }
      isGreaterThan(t) {
        return wr(this, t);
      }
      isLessThan(t) {
        return xr(this, t);
      }
      static calculate(t) {
        return Or(t);
      }
      static compare(t, e) {
        return Sr(t, e);
      }
      static equals(t, e) {
        return Cr(t, e);
      }
      static lessThan(t, e) {
        return xr(t, e);
      }
      static greaterThan(t, e) {
        return wr(t, e);
      }
      static min(...t) {
        return ((...t) => _r(...t)[0])(...t);
      }
      static max(...t) {
        return Er(...t);
      }
      static sortAsc(...t) {
        return _r(...t);
      }
      static sortDesc(...t) {
        return Lr(...t);
      }
    };
  const Ir = t => j(t, t => ('fulfilled' === t.status ? t.value : [t])),
    Nr = t => {
      const e = new Map(),
        n = t => {
          const n = e.get(t);
          if (g(n)) return n;
          {
            const n = Pr.calculate(t)[0];
            return e.set(t, n), n;
          }
        };
      return ((t, e) => {
        const r = L.call(t, 0);
        return (
          r.sort((t, e) => {
            const r = n(t.selector),
              o = n(e.selector);
            return Pr.compare(r, o);
          }),
          r
        );
      })(t);
    },
    jr = t => {
      const e = (t =>
        j(t, t =>
          (t => -1 !== t.selector.indexOf(','))(t)
            ? (t => {
                const e = t.selector.split(/,(?![^(]*\))/g);
                return P(e, e => {
                  const n = e.trim();
                  return { ...t, selector: n };
                });
              })(t)
            : [t]
        ))(t);
      return Nr(e);
    },
    Mr = t => {
      const e = {};
      return (
        I(t, n => {
          const r = t.getPropertyValue(n);
          c(r) && (e[n] = r);
        }),
        e
      );
    },
    Dr = t => ({ selector: t.selectorText, styles: Mr(t.style) }),
    Rr = (t, e) =>
      e(t).then(
        async t => {
          const n = j(t, t => {
              if (t.type === window.CSSRule.IMPORT_RULE) return [Rr(t.styleSheet, e)];
              if (t.type === window.CSSRule.STYLE_RULE) {
                const e = { status: 'fulfilled', value: [Dr(t)] };
                return [Promise.resolve([e])];
              }
              return [];
            }),
            r = await Promise.allSettled(n);
          return Ir(r);
        },
        t => Promise.resolve([{ status: 'rejected', reason: t }])
      ),
    Br = (t, e) => {
      var n, r;
      return ((t, e) => {
        const n = {};
        var r;
        return (
          ((t, e, n, r) => {
            it(t, (t, o) => {
              (e(t, o) ? n : r)(t, o);
            });
          })(
            t,
            e,
            ((r = n),
            (t, e) => {
              r[e] = t;
            }),
            v
          ),
          n
        );
      })(
        ((n = (t, e) => ({ ...t, ...e.styles })),
        (r = {}),
        I(e, (t, e) => {
          r = n(r, t);
        }),
        r),
        (e, n) => !O(t.dom.style, n)
      );
    },
    Ur = (t, e) => {
      const n = ((t, e) => R('style', K(t).dom))(t);
      lt(n, 'media', 'max-width: 1px'), Z(n, e);
      const r = (t =>
        (t => H(t) && g(t.dom.host))(t)
          ? t
          : (t => {
              const e = t.dom.head;
              if (null == e) throw new Error('Head is not available yet');
              return B(e);
            })(K(t)))(t);
      Y(r, n);
      const o = _.from(n.dom.sheet).fold(
        () => [],
        t => M(t.cssRules)
      );
      return X(n), o;
    };
  const $r = t => j(t, t => ('fulfilled' === t.status ? t.value : [])),
    Fr = jr,
    Vr = t => e => e.options.get(t),
    zr = Vr('body_class'),
    qr = Vr('body_id'),
    Wr = Vr('skin'),
    Gr = new Set([
      'margin',
      'margin-left',
      'margin-right',
      'margin-top',
      'margin-bottom',
      'padding',
      'padding-left',
      'padding-right',
      'padding-top',
      'padding-bottom',
      'border',
      'border-width',
      'border-style',
      'border-color',
      'background',
      'background-attachment',
      'background-clip',
      'background-color',
      'background-image',
      'background-origin',
      'background-position',
      'background-repeat',
      'background-size',
      'float',
      'position',
      'left',
      'right',
      'top',
      'bottom',
      'z-index',
      'display',
      'transform',
      'width',
      'max-width',
      'min-width',
      'height',
      'max-height',
      'min-height',
      'overflow',
      'overflow-x',
      'overflow-y',
      'text-overflow',
      'vertical-align',
      'transition',
      'transition-delay',
      'transition-duration',
      'transition-property',
      'transition-timing-function',
      'outline',
      'outline-color',
      'outline-style',
      'outline-width'
    ]),
    Hr = t => {
      const e = tt(t),
        n = ((t, e, n) =>
          N(
            ((t, e) => {
              const n = k(e) ? e : x;
              let r = t.dom;
              const o = [];
              for (; null !== r.parentNode && void 0 !== r.parentNode; ) {
                const t = r.parentNode,
                  e = B(t);
                if ((o.push(e), !0 === n(e))) break;
                r = t;
              }
              return o;
            })(t, n),
            e
          ))(
          t,
          t => U(t, '*'),
          t => {
            return (n = e), t.dom === n.dom;
            var n;
          }
        );
      return [t].concat(n);
    },
    Jr = (t, e) => {
      const n = (t => {
          const e = L.call(t, 0);
          return e.reverse(), e;
        })(Hr(t)),
        r = {},
        o = Fr(e);
      return (
        I(n, t => {
          const e = N(o, e => U(t, e.selector)),
            n = ((t, e) => {
              const n = {},
                r = P(e, t => t.styles),
                o = (t => {
                  const e = {},
                    n = t.dom;
                  if (ct(n))
                    for (let t = 0; t < n.style.length; t++) {
                      const r = n.style.item(t);
                      e[r] = n.style[r];
                    }
                  return e;
                })(t);
              return (
                I(r.concat([o]), t => {
                  it(t, (t, e) => {
                    var r;
                    ('background-color' !== e && ((r = e), Gr.has(r))) || (n[e] = t);
                  });
                }),
                n
              );
            })(t, e);
          it(n, (t, e) => {
            r[e] = t;
          });
        }),
        r
      );
    },
    Kr = (t, e) => {
      const n = Q(t);
      I(n, t => {
        var n;
        W((n = t)) &&
          z(n.dom) &&
          it(e, (e, n) => {
            ((t, e) => {
              const n = ((t, e) => (ct(t) ? t.style.getPropertyValue(e) : ''))(t.dom, e);
              return _.from(n).filter(t => t.length > 0);
            })(t, n).isNone() &&
              ((t, e, n) => {
                const r = t.dom;
                ut(r, e, n);
              })(t, n, e);
          });
      });
    },
    Qr = (t, e) => {
      (t => void 0 !== t.dom.classList)(t)
        ? t.dom.classList.add(e)
        : ((t, e) => {
            ((t, e, n) => {
              const r = ((t, e) => {
                  const n = ((t, e) => {
                    const n = t.dom.getAttribute(e);
                    return null === n ? void 0 : n;
                  })(t, e);
                  return void 0 === n || '' === n ? [] : n.split(' ');
                })(t, e),
                o = r.concat([n]);
              lt(t, e, o.join(' '));
            })(t, 'class', e);
          })(t, e);
    },
    Yr = t => {
      const e = B(
          (t => {
            if (g(t.target)) {
              const e = B(t.target);
              if (W(e) && g(e.dom.shadowRoot) && t.composed && t.composedPath) {
                const e = t.composedPath();
                if (e) return ((t, e) => (0 < t.length ? _.some(t[0]) : _.none()))(e);
              }
            }
            return _.from(t.target);
          })(t).getOr(t.target)
        ),
        n = () => t.stopPropagation(),
        r = () => t.preventDefault(),
        o = ((i = r), (s = n), (...t) => i(s.apply(null, t)));
      var i, s;
      return ((t, e, n, r, o, i, s) => ({ target: t, x: e, y: n, stop: r, prevent: o, kill: i, raw: s }))(
        e,
        t.clientX,
        t.clientY,
        n,
        r,
        o,
        t
      );
    },
    Xr = (t, e, n, r) => {
      t.dom.removeEventListener(e, n, r);
    },
    Zr = A,
    to = (t, e, n) =>
      ((t, e, n, r) =>
        ((t, e, n, r, o) => {
          const i = ((t, e) => n => {
            t(n) && e(Yr(n));
          })(n, r);
          return t.dom.addEventListener(e, i, o), { unbind: C(Xr, t, e, i, o) };
        })(t, e, n, r, !1))(t, e, Zr, n),
    eo = t => {
      const e = M(t);
      return (
        0 === e.length ||
        ((t, e) => {
          for (let e = 0, r = t.length; e < r; e++) if ('screen' === (n = t[e]) || 'all' === n) return !0;
          var n;
          return !1;
        })(e)
      );
    },
    no = t => !(t => 'CSSImportRule' === t.constructor.name)(t) || eo(t.media),
    ro = (t, e, n) => {
      const r = tt(t);
      return (async (t, e) => {
        const n = (t => {
            const e = t.dom.styleSheets;
            return Array.prototype.slice.call(e);
          })(t),
          r = P(n, t => Rr(t, e)),
          o = await Promise.allSettled(r);
        return Ir(o);
      })(r, t =>
        ((t, e, n) => (!!p(t.href) || (!e(t.href) && (m(n) || n(t.href)))) && (p(t.media) || eo(t.media)))(t, e, n)
          ? ((t, e) =>
              (t => {
                try {
                  return Promise.resolve(M(t.cssRules));
                } catch (t) {
                  return Promise.reject(t);
                }
              })(e).catch(n =>
                (async (t, e) =>
                  p(e.href)
                    ? Promise.resolve([])
                    : fetch(e.href)
                        .then(t => (t.ok ? t.text() : Promise.reject()))
                        .then(e => Ur(t, e))
                        .catch(t => []))(t, e)
              ))(r, t).then(t => N(t, no))
          : Promise.resolve([])
      ).then($r);
    },
    oo = async t => {
      const e = t.getContent(),
        n = (t => {
          const e = Wr(t),
            n = (t => {
              const e = Wr(t),
                n = t.options.get('skin_url');
              return !1 === e ? n : n ? t.documentBaseURI.toAbsolute(n) : t.editorManager.baseURL + '/skins/ui/' + e;
            })(t),
            r = t.editorManager.suffix;
          return !1 !== e && c(n) ? [n + `/skin${r}.css`, n + `/skin.shadowdom${r}.css`] : [];
        })(t),
        r = B(t.getBody()),
        o = await ro(r, t => O(n, t), void 0),
        i = (t => {
          const e = 'mce-sandbox';
          return {
            play: (n, r) =>
              new Promise((o, i) => {
                var s;
                const a = R('div'),
                  l = R('iframe');
                Qr(a, e), ht(a, { visibility: 'hidden' }), Y(a, l), Y(t, a);
                const c =
                    t =>
                    (...e) => {
                      X(a), t(...e);
                    },
                  u = null === (s = l.dom.contentWindow) || void 0 === s ? void 0 : s.document;
                if (m(u)) return void c(i)(new Error('sandbox iframe did not init correctly'));
                const h = to(l, 'load', () => {
                  h.unbind();
                  const t = B(u),
                    e = et(t);
                  r(t, e).then(c(o), c(i));
                });
                u.open(), u.write(n), u.close();
              }),
            playInline: (n, r) =>
              new Promise((o, i) => {
                const s = R('div');
                Qr(s, e),
                  ht(s, {
                    position: 'fixed',
                    overflow: 'hidden',
                    zIndex: '1000',
                    left: '0',
                    right: '0',
                    bottom: '0',
                    top: '0',
                    opacity: '0'
                  });
                const a = R('div');
                ht(a, { position: 'absolute', left: '0', right: '0', top: '0', height: 'auto', margin: 'auto' }),
                  Z(a, n),
                  Y(s, a),
                  Y(t, s);
                const l =
                  t =>
                  (...e) => {
                    X(s), t(...e);
                  };
                setTimeout(() => {
                  const e = J(t);
                  r(e, a).then(l(o), l(i));
                }, 50);
              })
          };
        })(et(B(document))),
        s = ((t, e) =>
          '<!DOCTYPE html><html><head><base href="' +
          (0, t.dom.encode)(t.documentBaseURI.getURI()) +
          '"></head>' +
          ((t, e) => {
            const n = t.dom.encode,
              r = qr(t),
              o = zr(t),
              i = t.getBody(),
              s = i.dir,
              a = s ? ' dir="' + n(s) + '"' : '',
              l = t.inline ? i.nodeName.toLowerCase() : 'body';
            return (
              `<${l} ${
                t.inline ? `class="mce-content-body"${a}` : `id="${n(r)}" class="mce-content-body ${n(o)}"${a}`
              }>` +
              e +
              `</${l}>`
            );
          })(t, e) +
          '</html>')(t, e);
      return i.play(s, (t, e) => {
        const n = nt(e, '.mce-content-body').getOr(e),
          i = (t => {
            const e = A;
            return N(
              t,
              t =>
                !(t =>
                  ((t, e, n = 0, r) => {
                    const o = t.indexOf(e, n);
                    return -1 !== o && (!!m(r) || o + e.length <= r);
                  })(t.selector, '::'))(t) && e(t.selector)
            );
          })(o);
        ((t, e, n) => {
          ((t, e, n) => {
            const r = [],
              o = document.createTreeWalker(t.dom, NodeFilter.SHOW_ELEMENT);
            for (; g(o.nextNode()); ) {
              const t = B(o.currentNode),
                n = N(e, e => U(t, e.selector));
              if (n.length > 0) {
                const e = Br(t, n);
                ht(t, e), r.push(t);
              }
            }
            n &&
              I(r, t => {
                t.dom.removeAttribute('class');
              });
          })(e, jr(t), n);
        })(i, n, !1);
        const s = Jr(r, i);
        return Kr(n, s), Promise.resolve({ html: ((a = n), a.dom.innerHTML) });
        var a;
      });
    },
    io = t => {
      const e = e => e(t),
        n = b(t),
        r = () => o,
        o = {
          tag: !0,
          inner: t,
          fold: (e, n) => n(t),
          isValue: A,
          isError: x,
          map: e => ao.value(e(t)),
          mapError: r,
          bind: e,
          exists: e,
          forall: e,
          getOr: n,
          or: r,
          getOrThunk: n,
          orThunk: r,
          getOrDie: n,
          each: e => {
            e(t);
          },
          toOptional: () => _.some(t)
        };
      return o;
    },
    so = t => {
      const e = () => n,
        n = {
          tag: !1,
          inner: t,
          fold: (e, n) => e(t),
          isValue: x,
          isError: A,
          map: e,
          mapError: e => ao.error(e(t)),
          bind: e,
          exists: x,
          forall: A,
          getOr: S,
          or: S,
          getOrThunk: w,
          orThunk: w,
          getOrDie:
            ((r = String(t)),
            () => {
              throw new Error(r);
            }),
          each: v,
          toOptional: _.none
        };
      var r;
      return n;
    },
    ao = { value: io, error: so, fromOption: (t, e) => t.fold(() => so(e), io) };
  var lo;
  !(function (t) {
    (t[(t.Error = 0)] = 'Error'), (t[(t.Value = 1)] = 'Value');
  })(lo || (lo = {}));
  const co = (t, e, n) => (t.stype === lo.Error ? e(t.serror) : n(t.svalue)),
    uo = t => ({ stype: lo.Value, svalue: t }),
    ho = t => ({ stype: lo.Error, serror: t }),
    po = co,
    fo = (t, e, n) => {
      switch (t.tag) {
        case 'field':
          return e(t.key, t.newKey, t.presence, t.prop);
        case 'custom':
          return n(t.newKey, t.instantiator);
      }
    },
    mo =
      ((go = (t, e) => (h(t) && h(e) ? mo(t, e) : e)),
      (...t) => {
        if (0 === t.length) throw new Error("Can't merge zero objects");
        const e = {};
        for (let n = 0; n < t.length; n++) {
          const r = t[n];
          for (const t in r) at(r, t) && (e[t] = go(e[t], r[t]));
        }
        return e;
      });
  var go;
  const ko = t => (u(t) && rt(t).length > 100 ? ' removed due to size' : JSON.stringify(t, null, 2)),
    yo = (t, e) => ho([{ path: t, getErrorInfo: e }]),
    vo = t => ({
      extract: (e, n) => {
        return (r = t(n)), (o = t => ((t, e) => yo(t, b(e)))(e, t)), r.stype === lo.Error ? o(r.serror) : r;
        var r, o;
      },
      toString: b('val')
    }),
    bo = (t, e, n, r) => r(st(t, e).getOrThunk(() => n(t))),
    So = (t, e, n, r, o) => {
      const i = t => o.extract(e.concat([r]), t),
        s = t =>
          t.fold(
            () => uo(_.none()),
            t => {
              const n = o.extract(e.concat([r]), t);
              return (i = n), (s = _.some), i.stype === lo.Value ? { stype: lo.Value, svalue: s(i.svalue) } : i;
              var i, s;
            }
          );
      switch (t.tag) {
        case 'required':
          return ((t, e, n, r) =>
            st(e, n).fold(
              () =>
                ((t, e, n) => yo(t, () => 'Could not find valid *required* value for "' + e + '" in ' + ko(n)))(
                  t,
                  n,
                  e
                ),
              r
            ))(e, n, r, i);
        case 'defaultedThunk':
          return bo(n, r, t.process, i);
        case 'option':
          return ((t, e, n) => n(st(t, e)))(n, r, s);
        case 'defaultedOptionThunk':
          return ((t, e, n, r) => r(st(t, e).map(e => (!0 === e ? n(t) : e))))(n, r, t.process, s);
        case 'mergeWithThunk':
          return bo(n, r, b({}), e => {
            const r = mo(t.process(n), e);
            return i(r);
          });
      }
    },
    Co = (t, e) =>
      vo(n => {
        const r = typeof n;
        return t(n) ? uo(n) : ho(`Expected type: ${e} but got: ${r}`);
      }),
    wo = Co(y, 'number'),
    xo = Co(c, 'string'),
    Ao = Co(f, 'boolean'),
    _o = (t, e, n) => {
      return (
        (r = ((t, e, n) =>
          ((t, e) => (t.stype === lo.Error ? { stype: lo.Error, serror: e(t.serror) } : t))(e.extract([t], n), t => ({
            input: n,
            errors: t
          })))(t, e, n)),
        co(r, ao.error, ao.value)
      );
      var r;
    },
    Lo = (t, e) =>
      ((t, e, n, r) => ({ tag: 'field', key: t, newKey: e, presence: n, prop: r }))(
        t,
        t,
        { tag: 'option', process: {} },
        e
      ),
    Eo = t => Lo(t, xo),
    To = (t, e) =>
      Lo(
        t,
        (t => {
          return (
            (e = e =>
              O(t, e) ? ao.value(e) : ao.error(`Unsupported value: "${e}", choose one of "${t.join(', ')}".`)),
            vo(t => e(t).fold(ho, uo))
          );
          var e;
        })(e)
      ),
    Oo =
      ((Po = [
        To('format', ['Letter', 'Legal', 'Tabloid', 'Ledger', 'A0', 'A1', 'A2', 'A3', 'A4', 'A5', 'A6']),
        Eo('margin_top'),
        Eo('margin_bottom'),
        Eo('margin_right'),
        Eo('margin_left'),
        Eo('header_html'),
        Eo('footer_html'),
        Eo('header_and_footer_css'),
        To('page_orientation', ['portrait', 'landscape']),
        ('wait_for_network', Lo('wait_for_network', Ao)),
        Lo('wait_time', wo)
      ]),
      {
        extract: (t, e) =>
          ((t, e, n) => {
            const r = {},
              o = [];
            for (const i of n)
              fo(
                i,
                (n, i, s, a) => {
                  const l = So(s, t, e, n, a);
                  po(
                    l,
                    t => {
                      o.push(...t);
                    },
                    t => {
                      r[i] = t;
                    }
                  );
                },
                (t, n) => {
                  r[t] = n(e);
                }
              );
            return o.length > 0 ? ho(o) : uo(r);
          })(t, e, Po),
        toString: () => {
          const t = P(Po, t =>
            fo(
              t,
              (t, e, n, r) => t + ' -> ' + r.toString(),
              (t, e) => 'state(' + t + ')'
            )
          );
          return 'obj{\n' + t.join('\n') + '}';
        }
      });
  var Po;
  const Io = { format: 'Letter', margin_top: '1in', margin_right: '1in', margin_bottom: '1in', margin_left: '1in' },
    No = t =>
      _.from('https://exportpdf.api.tiny.cloud/v1/convert')
        .map(t =>
          ((t, e) => {
            const n = new URL(t);
            return (n.pathname = '/v1/convert'), (n.search = ''), (n.hash = ''), n.toString();
          })(t)
        )
        .getOrDie('The Export PDF plugin requires the exportpdf_service_url option to be configured'),
    jo = t => _.from(t.options.get('exportpdf_converter_options')).getOr(Io),
    Mo = async t =>
      (t => _.from(t.options.get('exportpdf_token_provider')))(t).fold(
        () => Promise.resolve(_.none()),
        async t => {
          const e = t();
          if (!(u((n = e)) && k(n.then) && k(n.catch))) throw new Error('The token provider needs to return a promise');
          var n;
          const r = await e;
          if (!u(r) || !c(r.token))
            throw new Error('Token provider should return a promise with an object that has a token string property');
          return _.some(r.token);
        }
      ),
    Do = (t, e) => {
      const n = document.createElement('a');
      (n.href = window.URL.createObjectURL(t)), (n.download = e), n.click(), n.remove();
    },
    Ro = (t, e) => t.execCommand(e);
  tinymce.PluginManager.requireLangPack(
    'exportpdf',
    'ar,bg_BG,ca,cs,da,de,el,es,eu,fa,fi,fr_FR,he_IL,hi,hr,hu_HU,id,it,ja,kk,ko_KR,ms,nb_NO,nl,pl,pt_BR,pt_PT,ro,ru,sk,sl_SI,sv_SE,th_TH,tr,uk,vi,zh_CN,zh_TW'
  ),
    tinymce.PluginManager.add('exportpdf', t => {
      ((t, n) =>
        !!t &&
        -1 ===
          ((t, n) => {
            const r = e(t.major, n.major);
            if (0 !== r) return r;
            const o = e(t.minor, n.minor);
            if (0 !== o) return o;
            const i = e(t.patch, n.patch);
            return 0 !== i ? i : 0;
          })((t => r((t => [t.majorVersion, t.minorVersion].join('.').split('.').slice(0, 3).join('.'))(t)))(t), r(n)))(
        tinymce,
        '7.0'
      )
        ? console.error('The exportpdf plugin requires at least version 7.0 of TinyMCE.')
        : ((t => {
            t.options.register('exportpdf_service_url', {
              processor: t => {
                if (!c(t))
                  return (
                    console.error('The Export to PDF plugin requires the exportpdf_service_url to be configured'), !1
                  );
                try {
                  return new URL(t), !0;
                } catch (t) {
                  return console.error('The value provided in exportpdf_service_url is not a valid URL'), !1;
                }
              }
            }),
              t.options.register('exportpdf_converter_options', {
                processor: t =>
                  _o('exportpdf_converter_options', Oo, t).fold(
                    t => {
                      return (
                        console.error(
                          'Errors: \n' +
                            (t => {
                              const e =
                                t.length > 10
                                  ? t
                                      .slice(0, 10)
                                      .concat([{ path: [], getErrorInfo: b('... (only showing first ten failures)') }])
                                  : t;
                              return P(e, t => 'Failed path: (' + t.path.join(' > ') + ')\n' + t.getErrorInfo());
                            })((e = t).errors).join('\n') +
                            '\n\nInput object: ' +
                            ko(e.input)
                        ),
                        !1
                      );
                      var e;
                    },
                    t => !0
                  )
              }),
              t.options.register('exportpdf_converter_style', { processor: 'string', default: '' }),
              t.options.register('exportpdf_token_provider', { processor: 'function' });
          })(t),
          (t => {
            t.addCommand('ExportPDF', () => {
              (async (t, e) => {
                const n = (t => {
                    var e;
                    return null !== (e = t.options.get('directionality')) && void 0 !== e ? e : '';
                  })(t),
                  r = (t => t.options.get('exportpdf_converter_style'))(t),
                  o = e.converterUrl,
                  { html: i } = await (t => ({ getContent: () => oo(t) }))(t).getContent(),
                  s = {
                    html: `<html>\n      <head>\n        <meta charset="utf-8">\n      </head>\n      <body>\n        <div class="tinymce-content" dir="${n}">\n          ${i}\n        </div>\n      <body>\n    </html>`,
                    css: r,
                    options: e.converterOptions
                  },
                  a = {
                    method: 'POST',
                    headers: {
                      'Content-Type': 'application/json',
                      Accept: 'application/pdf',
                      ...(await Mo(t)).fold(
                        () => ({}),
                        t => ({ Authorization: t })
                      )
                    },
                    body: JSON.stringify(s)
                  };
                t.setProgressState(!0);
                const l = 'function' == typeof e.fileName ? e.fileName() : e.fileName;
                window
                  .fetch(o, a)
                  .then(t => {
                    if (200 !== t.status) throw t;
                    return t.blob();
                  })
                  .finally(() => t.setProgressState(!1))
                  .then(e => {
                    Do(e, l),
                      (t => {
                        t.dispatch('ExportToPdf');
                      })(t);
                  })
                  .catch(e => {
                    t.notificationManager.open({ text: 'Operation failed', type: 'error' }), console.error(e);
                  });
              })(t, { fileName: 'document.pdf', converterUrl: No(t), converterOptions: jo(t) });
            });
          })(t),
          (t => {
            t.ui.registry.addButton('exportpdf', {
              tooltip: 'Export to PDF',
              icon: 'export-pdf',
              onAction: () => {
                Ro(t, 'ExportPDF');
              },
              context: 'any'
            });
          })(t),
          (t => {
            t.ui.registry.addMenuItem('exportpdf', {
              text: 'Export to PDF...',
              icon: 'export-pdf',
              onAction: () => Ro(t, 'ExportPDF'),
              context: 'any'
            });
          })(t));
    });
})();
